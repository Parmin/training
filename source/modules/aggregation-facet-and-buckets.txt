====================================
Aggregation - ``$facet`` and Buckets
====================================


Learning Objectives
-------------------

Upon completing this module students should understand:

- How to use ``$bucket``
- How to use ``$bucketAuto``
- How to use ``$facet``
- How to combine ``$facet`` with buckets for a multi-faceted view


The ``$bucket`` stage
---------------------

- Groups documents based on a specified expression and bucket boundaries.
- Each bucket is represented as a document in the output.
- Each output document contains an _id field, whose value specifies the inclusive lower bound
- The count field is included by default when the output is not specified.


``$bucket`` Form
----------------

.. code-block:: js

   {
     $bucket: {
        groupBy: <expression>,
        boundaries: [ <lowerbound1>, <lowerbound2>, ... ],
        default: <literal>,
        output: {
           <output1>: { <$accumulator expression> },
           ...
           <outputN>: { <$accumulator expression> }
        }
     }
   }


``$bucket`` Exercise
--------------------

- Using our twitter dataset, let's group users by their tweet/retweet activity
- The bounds should be 0, 100, 500, 2000, 5000, 10000, and 25000
- Produce the following results

.. code-block:: js

   { "_id" : 0, "count" : 5036 }
   { "_id" : 100, "count" : 7711 }
   { "_id" : 500, "count" : 12205 }
   { "_id" : 2000, "count" : 9916 }
   { "_id" : 5000, "count" : 7229 }
   { "_id" : 10000, "count" : 6679 }
   { "_id" : 25000, "count" : 2652 }

.. only:: instructor

   .. note::

      - Can be read as 0-99, 100-499, ...
      - Lower bound is inclusive, upper bound is exclusive

      .. code-block:: js

         db.tweets.aggregate([
           {
             $bucket: {
               groupBy: "$user.statuses_count",
               boundaries: [0, 100, 500, 2000, 5000, 10000, 25000, Infinity],
               default: "Other",
               output: { "count": { $sum: 1 } }
             }
           }
         ])

``$bucketAuto``
---------------

- Groups documents into buckets much like ``$bucket``
- Bucket boundaries are determined by MongoDB in an attempt to evenly distribute the data


``$bucketAuto`` Exercise
------------------------

- Using our twitter dataset, use ``$bucketAuto`` to group documents into the following result

.. code-block:: js

   { "_id" : { "min" : 1, "max" : 342 }, "count" : 10287 }
   { "_id" : { "min" : 342, "max" : 1300 }, "count" : 10293 }
   { "_id" : { "min" : 1300, "max" : 3492 }, "count" : 10287 }
   { "_id" : { "min" : 3492, "max" : 9075 }, "count" : 10286 }
   { "_id" : { "min" : 9075, "max" : 518702 }, "count" : 10275 }

.. only:: instructor

   .. note::

      db.tweets.aggregate([
        {
          $bucketAuto: {
            groupBy: "$user.statuses_count",
            buckets: 5,
            output: {
              count: { $sum: 1 }
            }
          }
        }
      ])


``$facet``
----------

- Processes multiple aggregation pipelines within a single stage
- Each sub-pipeline has its own field in the output document
- Extremely powerful for data browsing and analysis
- Input documents are passed to ``$facet`` only once
- Can be used to avoid retrieving input documents multiple times
- Categorize and group incoming documents

``$facet`` (cont)
-----------------

- Has the following form

.. code-block:: js

   { $facet:
     {
       <outputField1>: [ <stage1>, <stage2>, ...<stageN>],
       <outputField2>: [ <stage1>, <stage2>, ...<stageN>],
       ...
     }
   }

Behavior
--------

 - Combined with ``$bucket``, ``$bucketAuto``, and ``$sortByCount`` performs a multi-faceted aggregation
 - Can't be used with the following:

   - ``$facet`` (Can't have a ``$facet`` within a ``$facet``)
   - ``$out``
   - ``$geoNear``
   - ``$indexStats``
   - ``$collStats``

Behavior (cont)
---------------

- Each sub-pipeline receives the exact same set of input documents
- Sub-pipelines are independent of each other
- Output from one sub-pipeline can not be used as input to a different sub-pipeline within the same ``$facet``

.. only:: instructor

   .. note::

      - It is possible to have multiple ``$facet`` stages within an overall aggregation.


``$facet`` Exercise
-------------------

Using our twitter dataset, output a single document with the following fields:

- **mostActive**: <User with the most **user.statuses_count** >

  - **screenName**: <**user.screen_name**>
  - **numTweetsAndRetweets**: <**user.statuses_count**>

- **leastActive**: <Of users who have at least 1 tweet/retweet, user with the least **statuses_count** and lexicographically first screen_name>

  - **screenName**: <**user.screen_name**>
  - **numTweetsAndRetweets**: <**user.statuses_count**>


``$facet`` Exercise (cont)
--------------------------


.. code-block:: js

   {
   	 "mostActive" : {
   		 "name": "currentutc",
   		 "numTweetsAndRetweets": 518702
   	  },
   	  "leastActive" : {
   		  "name": "ACunninghamMP",
   		  "numTweetsAndRetweets": 1
   	  }
   }

.. only:: instructor

   .. note::

      - Students should create an index to speed up this pipeline, have them use ``{ explain: true }`` to see if they are using an index
      - The fields will be returned as an array, remind students about ``$unwind``
      - One solution is the following:

      .. code-block:: js

         db.tweets.createIndex( { "user.statuses_count": 1, "user.screen_name": 1 })
         db.tweets.aggregate([
           { $match: { "user.statuses_count": { $gt: 0 } } },
           { $facet: {
               mostActive: [
                 { $sort: { "user.statuses_count": -1 } },
                 { $limit: 1 },
                 { $project: { _id: 0, name: "$user.screen_name", numTweetsAndRetweets: "$user.statuses_count" } }
               ],
               leastActive: [
                 { $sort: { "user.statuses_count": 1, "user.screen_name": 1 } },
                 { $limit: 1 },
                 { $project: { _id: 0, name: "$user.screen_name", numTweetsAndRetweets: "$user.statuses_count" } }
               ]
           } },
           { $unwind: "$mostActive" },
           { $unwind: "$leastActive" }
         ]).pretty()

Multi-faceted Aggregation Exercise
----------------------------------
