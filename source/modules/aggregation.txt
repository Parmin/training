===========
Aggregation
===========


Learning Objectives
-------------------

Upon completing this module students should understand:

- The concept of the aggregation pipeline
- The stages of the aggregation pipeline
- The syntax of aggregation stages


Aggregation Basics
------------------

- Use the aggregation framework to transform and analyze data in MongoDB collections.
- For those who are used to SQL, aggregation bears some similarities to the ``GROUP BY`` statement.
- The aggregation framework is based on the concept of a pipeline. 


The Aggregation Pipeline
------------------------

- An aggregation pipeline in analogous to a UNIX pipeline.
- Each stage of the pipeline:

  - Receives a set of documents as input.
  - Performs an operation on those documents.
  - Produces a set of documents for use by stages that follow.

- A pipeline has the following syntax:

  .. code-block:: javascript

     db.collection.aggregate( [ { stage1 }, { stage2 }, ... ],
                                { options } )


Aggregation Stages
------------------

- ``match``: Similar to ``find()``
- ``project``: Shape documents
- ``sort``: Like the cursor method of the same name
- ``skip``: Like the cursor method of the same name
- ``limit``: Like the cursor method of the same name 
- ``unwind``: Used for working with arrays
- ``group``: Used to aggregate field values from multiple documents
- ``out``: Creates a new collection from the output of an aggregation
  pipeline)


The Match Stage
---------------

- The ``$match`` operator works like the query parameter to ``find()``, ``update()``, and ``remove()``.
- Documents in the pipeline that match the query document will be passed on
- ``$match`` is often the first operator used in an aggregation stage.


Exercise: The Match Stage
-------------------------

Select only the first two documents using a match stage in an aggregation pipeline.

.. code-block:: javascript

    a = [ { _id : 1, a : 1 }, { _id : 2, a : 2 }, { _id : 3, a : 3 },
          { _id : 4, a : 4 }, { _id : 5, a : 5 } ]
    db.testcol.insert( a )

    // 2 docs are output from the aggregation pipeline
    db.testcol.aggregate( [ { $match : { a : { $lte : 2 } } } ] )  


The Project Stage
-----------------

- $project allows you to shape the documents into what you need for the next stage. 
- The simplest form of shaping is using $project to select only the fields you are interested in.
- You can also restructure documents that pass through a project stage.

  - E.g., you can pull a value out of an embedded document and put it at the top level.  
  - E.g., you can create a ratio from the values of two fields as pass along as a single field.

- $project produces 1 output document for every input document it sees.


Exercise: Selecting fields with $project
----------------------------------------

Use the $project operator to pass specific fields in output documents.

.. code-block:: javascript

   db.testcol.drop()
   for ( var i=1; i<=10; i++ ) { 
       db.testcol.insert( { a : i, b : i*2, c : { d : i*4, e : i*8 } } ) }
   db.testcol.find()

   db.testcol.aggregate( [ { $project : { a : 1 } } ] )

   db.testcol.aggregate( [ { $project : { _id : 0, a : 1 } } ] )

   db.testcol.aggregate( [ { $project : { a : 1, "c.d": 1 } } ] )

.. only:: instructor

   .. note::

      - ``{ $project : { a : 1 } }``: _id is projected implicitly
      - ``{ $project : { _id : 0, a : 1 } }``: supress projection of _id
      - ``{ $project : { a : 1, "c.d": 1 } }``: use dot notation to specify fields in embedded documents.


Exercise: Renaming fields with $project
---------------------------------------

Use the $project operator to rename a field

.. code-block:: javascript

   db.testcol.aggregate( [ { $project : { _id : 0, 
                                          sequenceNumber : "$a", 
                                          b : 1 } } ] )


Exercise: Shaping documents with $project
-----------------------------------------

Experiment with the following projections.

.. code-block:: javascript

   db.testcol.aggregate( [ { $project : { a : 1, b : 1, d : "$c.d" } } ] )

   db.testcol.aggregate( [ { $project : { sequenceNumber : "$a",
                                          ratio : { $divide : [ "$c.d", "$c.e" ] } } } ] )

More about :manual:`$divide</reference/operator/aggregation/divide/>` in another lesson.


A Twitter Dataset
-----------------

- We now have a basic understanding of the aggregation framework.
- Let's now look at some richer examples that illustrate the power of MongoDB aggregation.
- For these we will use a collection of tweets.
- As with any data of this type, it is a snapshot in time.
- It may not reflect the structure of Twitter feeds as the look today.


Tweets Data Model
-----------------

.. code-block:: javascript

   {
       "text" : "Something interesting ...",
       "entities" : {
	   "user_mentions" : [
	       {
		   "screen_name" : "somebody_else",
		   ...
	       }
	   ],
	   "urls" : [ ],
	   "hashtags" : [ ]
       },
       "user" : {
	   "friends_count" : 544,
	   "screen_name" : "somebody",
	   "followers_count" : 100,
	   ...
       },
   }


Analyzing Tweets
----------------

- Imagine the types of analyses one might want to do on tweets. 
- It is common to analyze the behavior of users and the networks involved. 
- Our examples will focus on this type of analysis

.. only:: instructor

   .. note::

      - We should also mention that our tweet documents actually contain many more fields.
      - We are showing just those relevant to the analyses we will do.


Rank Users by Number of Tweets
------------------------------

- With this type of data, it is common to rank users based on some metric.
- Let's look at who tweets the most.
- We will use the aggregation framework to do this.


Process
-------

- Group together all tweets by a user for every user in our collection
- Count the tweets for each user
- Sort in decreasing order


Exercise: Ranking Users by Number of Tweets
-------------------------------------------

Try this aggregation pipeline for yourself.

.. only:: instructor

   db.tweets.aggregate( [
       { $group: { _id: "$user.screen_name",
                   count: { $sum: 1 } } },
       { $sort: { count: -1 } } 
   ] )

.. only:: instructor

   .. note::

      - $group operations require that we specify which field to group on.
      - In this case, we group documents based on the user's screen name.
      - With $group, we aggregate values using arithmetic or array operators.
      - Here we are counting the number of documents for each screen name.
      - We do that by using the $sum operator 
      - This will add 1 to the count field for each document produced by the $group stage.
      - Note that there will be one document produced by $group for each screen name.
      - The $sort stage receives these documents as input and sorts them by the value of the count field


Exercise: Tweet Source
----------------------

- The tweets in our twitter collection have a field called "source". 
- This field describes the application that was used to create the tweet. 
- Write an aggregation pipeline that identifies the applications most frequently used to publish tweets.

.. only:: instructor

   .. note::

      .. code-block:: javascript

	 db.tweets.aggregation( [
	     { "$group" : { "_id" : "$source",
			    "count" : { "$sum" : 1 } } },
	     { "$sort" : { "count" : -1 } } 
	 ] )



The Group Stage
----------------

- For those coming from the relational world, ``$group`` is similar to the SQL ``GROUP BY`` statement.
- $group operations require that we specify which field to group on.
- Documents with the same identifier will be aggregated together.
- With $group, we aggregate values using arithmetic or array operators.


Group using $avg
----------------

.. code-block:: javascript

   db.testcol.aggregate( [ { $group : { _id : { a : "$a" },
                                        b_avg : { $avg : "$b" } } } ] )


Group using $push
-----------------

For each user, aggregate all their tweets into a single array.

.. code-block:: javascript

   db.tweets.aggregate( [
      { "$group" : { "_id" : "$user.screen_name",
                     "tweet_texts" : { "$push" : "$text" },
                     "count" : { "$sum" : 1 } } },
      { "$sort" : { "count" : -1 } },
      { "$limit" : 5 } 
   ] )



Group Aggregation Operators
---------------------------

The complete list of operators available in the group stage:

- $addToSet
- $first
- $last
- $max
- $min
- $avg
- $push
- $sum



Friends and Followers
---------------------

- Let's look again at two stages we touched on earlier:

  - ``$match``
  - ``$project``

- In our dataset:

  - ``friends`` are those a user follows.
  - ``followers`` are others that follow a users. 

- Using these operators we will write an aggregation pipeline that will:

  - Ignore anyone with no friends and no followers.
  - Calculate who has the highest followers to friends ratio.


Exercise: Friends and Followers
-------------------------------

.. code-block:: javascript

   db.tweets.aggregate( [
       { $match: { "user.friends_count": { $gt: 0 },
		   "user.followers_count": { $gt: 0 } } },
       { $project: { ratio: {$divide: ["$user.followers_count",
		 		       "$user.friends_count"]},
		     screen_name : "$user.screen_name"} },
       { $sort: { ratio: -1 } },
       { $limit: 1 } ] )

.. only:: instructor

   .. note::

      - Discuss the $match stage
      - Discuss the $project stage as a whole
      - Remember that with project we can pull a value out of an embedded document and put it at the top level.
      - Discuss the ratio projection
      - Discuss screen_name projection
      - Give an overview of other operators we might use in projections


Exercise: $match and $project
-----------------------------

- Of the users in the "Brasilia" timezone who have tweeted 100 times or more, who has the largest number of followers?
- Time zone is found in the “time_zone” field of the user object in each tweet.
- The number of tweets for each user is found in the “statuses_count” field.
- Your result document should look something like the following:

  .. code-block:: javascript

     { u'_id': ObjectId('52fd2490bac3fa1975477702'),
       u'followers': 2597,
       u'screen_name': u'marbles',
       u'tweets': 12334}


.. only:: instructor

   .. note:: 

      .. code-block:: javascript

         [ { "$match" : { "user.time_zone" : "Brasilia",
	 		  "user.statuses_count" : {"$gte" : 100} } },
           { "$project" : { "followers" : "$user.followers_count",
                            "tweets" : "$user.statuses_count",
                            "screen_name" : "$user.screen_name" } },
           { "$sort" : { "followers" : -1 } },
           { "$limit" : 1 } ]



The Unwind Stage
----------------

- In many situations we want to aggregate using values in an array field.
- In our tweets dataset we need to do this to answer the question:

  - "Who includes the most user mentions in their tweets?"

- User mentions are stored as within an embedded document for entities.
- This embedded document also lists any urls and hashtags used in the tweet.


Example: User Mentions in a Tweet
---------------------------------

.. code-block:: javascript

   ...
   "entities" : {
       "user_mentions" : [
           {
               "indices" : [
                   28,
                   44
               ],
               "screen_name" : "LatinsUnitedGSX",
               "name" : "Henry Ramirez",
               "id" : 102220662
           }
       ],
       "urls" : [ ],
       "hashtags" : [ ]
    },
    ...


Using $unwind
-------------

Who includes the most user mentions in their tweets?

.. code-block:: javascript

   db.tweets.aggregate(
       { $unwind: "$entities.user_mentions" },
       { $group: { _id: "$user.screen_name",
		   count: { $sum: 1 } } },
       { $sort: { count: -1 } },
       { $limit: 1 })


.. only:: instructor

   .. note::

      - Many tweets contain multiple user mentions.
      - We use unwind to produce one document for each user mention.
      - Each of these documents is passed to the $group stage that follows.
      - They will be grouped by the user who created the tweet and counted.
      - As a result we will have a count of the total number of user mentions made by any one tweeter.


Data Processing Pipelines
-------------------------

- The aggregation framework allows you to create a data processing pipeline.
- You can include as many stages as necessary to achieve your goal.
- For each stage consider:

  - What input that stage must receive
  - What output it should produce.

- Many tasks require us to include more than one stage using a given operator. 


Most Unique User Mentions
-------------------------

- We frequently need multiple group stages to achieve our goal.
- We just looked at a pipeline to find the tweeter that mentioned the most users.
- Let's change this so that it is more of a question about a tweeter's active network. 
- We might ask which tweeter has mentioned the most unique users in their tweets.


Same Operator ($group), Multiple Stages
---------------------------------------

Which tweeter has mentioned the most unique users in their tweets?

.. code-block:: javascript

   db.tweets.aggregate( [
       { $unwind: "$entities.user_mentions" },
       { $group: { 
           _id: "$user.screen_name",
	   mset: { $addToSet: "$entities.user_mentions.screen_name"  } } },
       { $unwind: "$mset"},
       { $group: { _id: "$_id", count: { $sum: 1 } } },
       { $sort: { count: -1 } },
       { $limit: 1 } 
   ] )

.. only:: instructor

   .. note::

      - We begin as we did before by unwinding user mentions.
      - Instead of simple counting them, we aggregate using $addToSet.
      - This produces documents that include only unique user mentions.
      - We then do another unwind stage to produce a document for each unique user mention.
      - And count these in a second $group stage. 


The Sort Stage
--------------

- Uses the $sort operator
- Works like the ``sort()`` cursor method
- 1 to sort ascending; -1 to sort descending
- E.g, db.testcol.aggregate( [ { $sort : { b : 1, a : -1 } } ] )


The Skip Stage
--------------

- Uses the $skip operator
- Works like the ``skip()`` cursor method.
- Value is an integer specifying the number of documents to skip.
- E.g, the following will pass all but the first 3 documents to the next stage in the pipeline.

  - db.testcol.aggregate( [ { $skip : 3 }, ... ] )



The Limit Stage
---------------

- Used to limit the number of documents passed to the next aggregation stage.
- Works like the ``limit()`` cursor method.
- Value is an integer.
- E.g., the following will only pass 3 documents to the stage that comes next in the pipeline.

  - db.testcol.aggregate( [ { $limit: 3 }, ... ] )


The Out Stage
-------------

- Used to create a new collection from the output of the aggregation pipeline.
- Can only be the last stage in the pipeline.
- If a collection by the name already exists, it replaces that collection.
- Syntax is { $out : "collection_name" }




