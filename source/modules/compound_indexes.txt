================
Compound Indexes
================

.. topic:: Upon completing this module students should understand:

   - What a compound index is.
   - How compound indexes are created.
   - The importance of considering field order when creating compound indexes.
   - How to efficiently handle queries involving some combination of equality matches, ranges, and sorting.
   - Some limitations on compound indexes.

Introduction to Compound Indexes
--------------------------------

- It is common to create indexes based on more than one field.
- Recall that these are called ``compound indexes``.
- You may use up to 31 fields in a compound index.  
- You many not use hashed fields.
- The order in which the fields are specified is of critical importance.
- Specifically we want to consider how the index will be used for:

  - Equality tests, e.g., 
    ::
    
       db.example.find( { a : 15, b : 17 } )

  - Range queries, e.g., 
    ::

       db.example.find( { a : 15, b : { $lt : 85 } } )

  - Sorting, e.g., 
    ::

       db.example.find( { a : 15, b : 17 } ).sort( { b : -1 } )

- It is especially important to consider query patterns that require two or more of these operations.


Designing Compound Indexes
--------------------------

- Our objective here is to develop some guiding principles for building compound indexes.
- This will generally produce a good if not optimal index.
- You can optimize after a little experimentation.
- We will explore this in the context of a running example.

Example: A Simple Message Board
-------------------------------

Objective:
~~~~~~~~~~

- Find all messages in a specified timestamp range.
- Select for whether the messages are anonymous or not.
- Sort by rating from highest to lowest.

Load this data into a new collection:

.. code-block:: javascript

   a = [ { "timestamp" : 1, "username" : "anonymous", "rating" : 3 },
         { "timestamp" : 2, "username" : "anonymous", "rating" : 5 },
         { "timestamp" : 3, "username" : "sergio", "rating" : 1 },
         { "timestamp" : 4, "username" : "anonymous", "rating" : 2 },
         { "timestamp" : 5, "username" : "martha", "rating" : 5 } ]
   db.messages.insert(a)

Start by building an index on { timestamp : 1 }

.. code-block:: javascript

   db.messages.ensureIndex( { timestamp : 1 }, { name : "myindex" } )

Now let's query for messages with timestamp in the range 2 through 4 inclusive.

.. code-block:: javascript

   db.messages.find( { timestamp : { $gte : 2, $lte : 4 } } ).explain()

Better, but not complete
~~~~~~~~~~~~~~~~~~~~~~~~

- Explain plan shows good performance, i.e. ``nscanned`` = ``n``.  
- However, this does not satisfy our query.  
- Need to query again with { username : "anonymous" } as part of the query.

Let's add the ``user`` field to our query.

.. code-block:: javascript

   db.messages.find( { timestamp : { $gte : 2, $lte : 4 }, 
                       username : "anonymous" } ).explain()

Now ``nscanned`` > ``n``. Let's build a compound index.

.. code-block:: javascript

   db.messages.dropIndex( "myindex" );
   db.messages.ensureIndex( { timestamp : 1, username : 1 }, 
                            { name : "myindex" } )
   db.messages.find( { timestamp : { $gte : 2, $lte : 4 }, 
                       username : "anonymous" } ).explain()

Why is ``nscanned`` > ``n``?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

- The index we have created stores the range values before the equality values.
- The documents with timestamp values 2, 3, and 4 were found first.
- Then the associated anonymous values had to be evaluated.

=========  ===========
timestamp  username
=========  ===========
1          "anonymous"
2          "anonymous"
3          "sergio"
4          "anonymous"
5          "martha"
=========  ===========


Drop the index and build a new one with user.

.. code-block:: javascript

   db.messages.dropIndex( "myindex" );
   db.messages.ensureIndex( { username : 1 , timestamp : 1 }, 
                            { name : "myindex" } )
   db.messages.find( { timestamp : { $gte : 2, $lte : 4 }, 
                       username : "anonymous" } ).explain()

Now ``nscanned`` is 2 and ``n`` is 2. The following illustrates very simply the difference in the way the index is structured and why this is better for this query.

===========  =========
username     timestamp
===========  =========
"anonymous"  1
"anonymous"  2
"anonymous"  4
"sergio"     2
"martha"     5
===========  =========

Let Selectivity Drive Field Order
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

- Order fields in a compound index from most selective to least selective.
- Usually, this means equality fields before range fields.
- When dealing with multiple equality values, start with the most selective.
- If a common range query is more selective than the equality test (rare), specify the range component first.

Finally, let's add the sort and run the query.

.. code-block:: javascript

   db.messages.find( { 
                       timestamp : { $gte : 2, $lte : 4 }, 
                       username : "anonymous" 
                     } ).sort( { rating : -1 } ).explain();


In-Memory Sorts
~~~~~~~~~~~~~~~

- Note that the ``scanAndOrder`` field is set to true.
- This means that MongoDB had to perform a sort in memory.  
- In memory sorts for queries that retrieve large numbers of documents can degrade performance significantly.
- Especially, if they are used frequently.

We will modify the index again to allow the database to sort for us.

.. code-block:: javascript

   db.messages.dropIndex( "myindex" );
   db.messages.ensureIndex( { username : 1 , timestamp : 1, rating : 1 }, 
                            { name : "myindex" } );
   db.messages.find( { 
                       timestamp : { $gte : 2, $lte : 4 }, 
                       username : "anonymous" 
                     } ).sort( { rating : -1 } ).explain();

Why is the explain plan unchanged?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

- The field being sorted on comes after the range fields.
- The index does not store entries in order by rating.
- To have the index structured this way we need to specify the field for sorting (rating) before the range field (timestamp).
- Note that this requires to consider a tradeoff.

Rebuild the index as follows.

.. code-block:: javascript

   db.messages.dropIndex( "myindex" );
   db.messages.ensureIndex( { username : 1, rating : 1, timestamp : 1 }, 
                            { name : "myindex" } );
   db.messages.find( { 
                       timestamp : { $gte : 2, $lte : 4 }, 
                       username : "anonymous" 
                     } ).sort( { rating : -1 } ).explain();

Tradeoff Between ``nscanned`` and ``scanAndOrder``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

- Now ``scanAndOrder`` is set to ``false``. 
- However, ``nscanned`` is 3 and and ``n`` is 2. 
- This is the best we can do in this case and in this situation is fine.
- However, if ``nscanned`` is much larger than ``n``, this might not be the best index.  
- You will have to evaluate your use case to determine how to make this tradeoff.

General Rules of Thumb
----------------------

- Equality before sorting.  
- Sorting before range.


