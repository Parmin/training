==============================
Reading Documents (C++ Driver)
==============================


Learning Objectives
-------------------

Upon completing this module students should understand:

- The query-by-example paradigm of MongoDB
- How to query on array elements
- How to query embedded documents using dot notation
- How the mongo shell and drivers use cursors
- Projections
- Cursor methods: ``.count()``, ``.sort()``, ``.skip()``, ``.limit()``

.. include:: /includes/student-notes.rst


The ``find()`` Method
---------------------

- This is the fundamental method by which we read data from MongoDB.
- We have already used it in its basic form.
- ``find()`` returns a cursor that enables us to iterate through all documents matching a query.
- We will discuss cursors later.

.. include:: /includes/student-notes.rst


Query by Example
----------------

- To query MongoDB, specify a document containing the key / value pairs you want to match
- You need only specify values for fields you care about.
- Other fields will not be used to exclude documents.
- The result set will include all documents in a collection that match.

.. include:: /includes/student-notes.rst


Example: Querying by Example
----------------------------

Experiment with the following sequence of commands.

.. code-block:: cpp

  collection coll = conn["sample"]["sports"];
  coll.drop();
  //insert documents
  std::vector<bsoncxx::document::view> docs{};
  auto b0 = document{} << "_id" << 0 << "name" << "Badminton" << "indoor" << true << finalize;
  auto b1 = document{} << "_id" << 1 << "name" << "Snooker" << "indoor" << true << finalize;
  docs.push_back(b0.view());
  docs.push_back(b1.view());
  coll.insert_many(docs);
  // find all documents in collection - db.sports.find()
  coll.find({});
  // find documents that match name = Snooker
  document query = document{} << "name" << "Snooker";
  coll.find(query);

  // Multiple indoor sports but only one that is called Badminton
  document query = document{} << "name" << "Snooker" << "indoor" << true;
  coll.find(query);
.. include:: /includes/student-notes.rst


.. only:: instructor

   .. note::

      Matching Rules:

      - Any field specified in the query must be in each document returned.
      - Values for returned documents must match the conditions specified in the query document.
      - If multiple fields are specified, all must be present in each document returned.
      - Think of it as a logical AND for all fields.

      In the C++ driver context we need to explain to students that:

      - we create query documents with the same process as any other document
      - views, read only objects that document builders produce, are sent has query matching to `find()` method
      - introduce helper `bsoncxx::to_json(...)` to prettify the output



Querying Arrays
---------------

- In MongoDB you may query array fields.
- Specify a single value you expect to find in that array in desired documents.
- Alternatively, you may specify an entire array in the query document.
- As we will see later, there are also several operators that enhance our ability to query array fields.

.. include:: /includes/student-notes.rst

.. only:: instructor

   .. note::

      Students might find it helpful to think of an array field as having multiple values -- one for each of its elements.


Example: Querying Arrays
------------------------

Let's assume the following dataset:

.. code-block:: cpp

  auto b0 = document{} << "name" << "Badminton"
      << "category" << open_array
        << "field" << "indoor" << "pairs" << "individual" << close_array
      << finalize;
  auto b1 = document{} << "name" << "Javelin throw"
      << "category" << open_array
        << "individual" << "track" << "outdoors" << close_array
      << finalize;
  auto b2 = document{} << "name" << "Football (not soccer!)"
      << "category" << open_array
        << "team" << "field" << "outdoors" << close_array
      << finalize;
  std::vector<bsoncxx::document::view> docs{};
  docs.push_back(b0.view());
  docs.push_back(b1.view());
  docs.push_back(b2.view());
  auto options = options::insert{};
  options.ordered(true);
  coll.insert_many(docs, options );

.. include:: /includes/student-notes.rst

.. only:: instructor

  .. note::

    Important note here is the usage of ``bsoncxx::builder::stream::open_array``
    builder helper.
    There are several different `helpers <http://mongodb.github.io/mongo-cxx-driver/stream_2helpers_8hpp_source.html>`_
    for the different structural document substructures.

    Make sure your students are aware of these.


Example: Querying Arrays
------------------------

.. code-block:: cpp

  // Match documents where "category" contains the value specified
  auto query0 = document{} << "category" << "field" << finalize;
  // Should return 2 documents
  auto cur = coll.find(query0.view());


  // Match documents where "category" equals the value specified
  auto query1 = document{} << "category" << open_array
    << "team" << close_array
  << finalize;
  // no documents
  auto cur = coll.find(query1.view());

  // only the second document
  auto query2 = document{} << "category" << open_array
    << "individual" << "track" << "outdoors" << close_array
  << finalize;
  auto cur = coll.find(query2.view());

.. include:: /includes/student-notes.rst


.. only:: instructor

   .. note::

      Later, we'll see operators that will allow us to do things like match all documents where an array field contains any of a set of values.


Querying with Dot Notation
--------------------------

- Dot notation is used to query on fields in embedded documents.
- The syntax is:

  .. code-block:: javascript

     "field1.field2" : value

- Put quotes around the field name when using dot notation.

.. include:: /includes/student-notes.rst


Example: Querying with Dot Notation
-----------------------------------

Using the following documents

.. code-block:: cpp

  auto b0 = document{} << "name" << "Football (not soccer!)"
      << "worldcup" << open_document
        << "host" << "Brazil"
        << "teams" << 32
        << "champion" << "Germany"
      << close_document
    << finalize;
  auto b1 = document{} << "name" << "Rugby"
      << "worldcup" << open_document
        << "host" << "England"
        << "teams" << 20
        << "champion" << "New Zeland"
      << close_document
    << finalize;
  coll.insert_one(b0.view());
  coll.insert_one(b1.view());
  // find worldcup with 40 teams
  auto query0 = document{} << "worldcup.teams" << 40 << finalize;
  coll.find(query0.view()) // no values

.. include:: /includes/student-notes.rst

.. only:: instructor

  .. note::

    Make sure you ensure that students understand the end result documents by querying the database

    .. code-block:: bash

      mongo sample --eval 'printjson(db.sports.find())'


Example: Querying with Dot Notation
-----------------------------------

.. code-block:: cpp

  // find worldcup is {teams : 32}
  auto query0 = document{} << "worldcup"<< open_document
      << "teams" << 32
    << close_document
  << finalize;
  iterate_cursor(coll.find(query0.view()), "query0");
  // how many values should the above query return ?

   // dot notation
   auto query1 = document{} << "worldcup.teams" << 32 << finalize;
   coll.find(query1.view())


.. include:: /includes/student-notes.rst

.. only:: instructor

  .. note::

    Important to explain the differences between matching query and dot notation!

    You can use the white board to diagram the different object creation and matching of document fields.

Example: Arrays and Dot Notation
--------------------------------

Using the `mongo` shell we can create the following dataset:

.. code-block:: javascript

   db.movies.insert( [
       { "title" : "E.T.",
         "filming_locations" :
            [ { "city" : "Culver City", "state" : "CA", "country" : "USA" },
              { "city" : "Los Angeles", "state" : "CA", "country" : "USA" },
              { "city" : "Cresecent City", "state" : "CA", "country" : "USA" }
            ] },
       { "title": "Star Wars",
         "filming_locations" :
            [ { "city" : "Ajim", "state" : "Jerba", "country" : "Tunisia" },
              { "city" : "Yuma", "state" : "AZ", "country" : "USA" }
            ] } ] )

.. include:: /includes/student-notes.rst



Example: Arrays and Dot Notation
--------------------------------

.. code-block:: cpp

  // db.movies.find( { "filming_locations.country" : "USA" } )
  auto query = document{} << "filming_locations.country"<< "USA"<< finalize;
  coll.find(query.view()); // two documents


.. only:: instructor

   .. note::

      - This query finds documents where:

        - There is a ``filming_locations`` field.
        - The ``filming_locations`` field contains one or more embedded documents.
        - At least one embedded document has a field ``country``.
        - The field ``country`` has the specified value ("USA").

      - In this collection, ``filming_locations`` is actually an array field.
      - The embedded documents we are matching are held within these arrays.


Projections
-----------

- You may choose to have only certain fields appear in result documents.
- This is called projection.
- You specify a projection by passing a second parameter to ``find()``.

.. include:: /includes/student-notes.rst


Projection: Example (Setup)
---------------------------

.. code-block:: javascript

   db.movies.insert(
   {
      "title" : "Forrest Gump",
      "category" : [ "drama", "romance" ],
      "imdb_rating" : 8.8,
      "filming_locations" : [
        { "city" : "Savannah", "state" : "GA", "country" : "USA" },
        { "city" : "Monument Valley", "state" : "UT", "country" : "USA" },
        { "city" : "Los Anegeles", "state" : "CA", "country" : "USA" }
      ],
      "box_office" : {
        "gross" : 557,
        "opening_weekend" : 24,
        "budget" : 55
      }
    })

.. include:: /includes/student-notes.rst

Projection: Example
-------------------

.. code-block:: cpp

   document query;
   document projection;
   //db.movies.findOne( { "title" : "Forrest Gump" }, { "title" : 1, "imdb_rating" : 1 } )
   query << "title" << "Forrest Gump";
   projection <<  "title" << 1 << "imdb_rating" << 1;
   options::find opts;
   opts.projection( projection.view());
   coll.find(query.view(), opts);
   /*
     {
      "_id" : {
          "$oid" : "56e99cf3d7de9ca24ffc54e6"
      },
      "title" : "Forrest Gump",
      "imdb_rating" : 8.8
      }
   */

.. include:: /includes/student-notes.rst


Projection Documents
--------------------

- Include fields with ``fieldName: 1``.

  - Any field not named will be excluded
  - except _id, which must be explicitly excluded.

- Exclude fields with ``fieldName: 0``.

  - Any field not named will be included.

.. include:: /includes/student-notes.rst


Example: Projections
--------------------

.. code-block:: javascript

   for (i=1; i<=20; i++) {
       db.movies.insert( { "_id" : i, "title" : i,
                           "imdb_rating" : i, "box_office" : i } )
   }
   db.movies.find()
   // no "box_office"
   db.movies.find( { "_id" : 3 }, { "title" : 1, "imdb_rating" : 1 } )
   // no "imdb_rating"
   db.movies.find( { "_id" : { $gte : 10 } }, { "imdb_rating" : 0 } )
   // just "title"
   db.movies.find( { "_id" : 4 }, { "_id" : 0, "title" : 1 } )
   // just "imdb_rating", "box_office"
   db.movies.find( { "_id" : 5 }, { _id : 0, "title" : 0 } )
   // Can't mix inclusion/exclusion except _id
   db.movies.find( { "_id" : 6 }, { "title" : 1, "imdb_rating" : 0 } )

.. only:: instructor

   The last ``find()`` fails because MongoDB cannot determine how to handle unnamed fields such as ``c``.

.. include:: /includes/student-notes.rst


Cursors
-------

- When you use ``find()``, MongoDB returns a cursor.
- A cursor is a pointer to the result set
- You can get iterate through documents in the result using ``next()``.
- By default, the mongo shell will iterate through 20 documents at a time.

.. include:: /includes/student-notes.rst


Example: Introducing Cursors
----------------------------

.. code-block:: cpp

    collection coll = conn["sample"]["iterate"];
    coll.drop();
    for (int i=1; i<=10000; i++) {
        document b0;
        b0 << "i" << i;
        coll.insert_one(b0.view());
    }

    cursor c = coll.find({});

    for ( auto&& d : c ){
      std::cout << bsoncxx::to_json(d) << std::endl;
    }


.. include:: /includes/student-notes.rst

.. only:: instructor

  .. note::

    Important to note that the `cursor` operates over batches of results that the server sends back to the client application.

    The size of cursor can be defined using ``mongocxx::options::find`` options.

    .. code-block:: cpp

      mongocxx::options::find opts;
      opts.batch_size(30);
      coll.find({}, opts);



Example: Cursor Objects in the Mongo Shell
------------------------------------------

.. code-block:: javascript

   // Assigns the cursor returned by find() to a variable x
   var x = db.testcol.find()

   // Displays the first document in the result set.
   x.next()

   // True because there are more documents in the result set.
   x.hasNext()

   // Assigns the next document in the result set to the variable y.
   y = x.next()

   // Return value is the value of the a field of this document.
   y.a

   // Displaying a cursor prints the next 20 documents in the result set.
   x

.. include:: /includes/student-notes.rst



Shell Cursor Methods
--------------------

The `mongo` shell offers some cursor helper methods:

- ``count()``: Returns the number of documents in the result set.
- ``limit()``: Limits the result set to the number of documents specified.
- ``skip()``: Skips the number of documents specified.

These are not present in the **c++** cursor object!

.. include:: /includes/student-notes.rst


Example: Using ``count()``
--------------------------

.. code-block:: javascript

   db.testcol.drop()
   for (i=1; i<=100; i++) { db.testcol.insert( { a : i } ) }

   // all 100
   db.testcol.count()

   // just 41 docs
   db.testcol.count( { a : { $lt : 42 } } )

   // Another way of writing the same query
   db.testcol.find( { a : { $lt : 42 } } ).count(  )

To perform a count in **c++** you should use the following method:

.. code-block:: cpp

  cursor c = coll.find({});
  std::distance(c.begin(), c.end());

.. include:: /includes/student-notes.rst

.. only:: instructor

   .. note::

      - You may pass a query document like you would to ``find()``.
      - ``count()`` will count only the documents matching the query.
      - Will return the number of documents in the collection if you do not specify a query document.
      - The last query in the above achieves the same result because it operates on the cursor returned by ``find()``.



Example: Using ``sort()``
-------------------------

.. code-block:: javascript

   db.testcol.drop()
   for (i=1; i<=20; i++) {
       db.testcol.insert( { a : Math.floor( Math.random() * 10 + 1 ),
                            b : Math.floor( Math.random() * 10 + 1 ) } )
   }
   db.testcol.find()

   // sort descending; use 1 for ascending
   db.testcol.find().sort( { a : -1 } )

   // sort by b, then a
   db.testcol.find().sort( { b : 1, a : 1 } )

   // $natural order is just the order on disk.
   db.testcol.find().sort( { $natural : 1 } )

.. include:: /includes/student-notes.rst

.. only:: instructor

   .. note::

      - Sort can be executed on a cursor until the point where the first document is actually read.
      - If you never delete any documents or change their size, this will be the same order in which you inserted them.
      - Sorting two or more fields breaks the convention of javascript objects that key / value pairs are unordered.
      - In some drivers you may need to take special care with this.
      - For example, in Python, you would usually query with a dictionary.
      - But dictionaries are unordered in Python, so you would use an array of tuples instead.

Example: Using ``sort()`` C++
-----------------------------

To perform ``sort`` operations in **c++** we need to use the following:

.. code-block:: cpp

  mongocxx::options::find opts;
  // sort a descending
  auto sortby = document{} << "a" << -1 << finalize;

  // sort a ascending
  auto sortby = document{} << "a" << 1 << finalize;

  // sort by natural insert order
  auto sortby = document{} << "$natural" << 1 << finalize;

  opts.sort(sortby.view());
  coll.find({}, opts);


.. include:: /includes/student-notes.rst

.. only:: instructor

  .. note::

    As in any of the following `cursor` methods, these will be achieved by
    providing our find method the respective ``mongocxx::options::find``.

    The list of options has both cursor operations but also connection and other
    attributes relevant to perform a query:

    - hint
    - limit
    - max_await_time
    - max_time
    - batch_size
    - allow_partial_results
    - projection
    - read_preference
    - skip
    - ...

The ``skip()`` Method
---------------------

- Skips the specified number of documents in the result set.
- The returned cursor will begin at the first document beyond the number specified.

.. include:: /includes/student-notes.rst


The ``limit()`` Method
----------------------

- Limits the number of documents in a result set to the first ``k``.
- Specify ``k`` as the argument to ``limit()``
- Helps reduce resources consumed by queries.

.. include:: /includes/student-notes.rst


The ``distinct()`` Method
-------------------------

- Returns all values for a field found in a collection.
- Only works on one field at a time.
- Input is a string (not a document)

.. include:: /includes/student-notes.rst


Example: Using ``distinct()`` shell
-----------------------------------

.. code-block:: javascript

   db.movie_reviews.drop()
   db.movie_reviews.insert( [ { "title" : "Jaws", "rating" : 5 },
                              { "title" : "Home Alone", "rating" : 1 },
                              { "title" : "Jaws", "rating" : 7 },
                              { "title" : "Jaws", "rating" : 4 },
                              { "title" : "Jaws", "rating" : 8 } ] )
   db.movie_reviews.distinct( "title" )


.. only:: instructor

  .. note::

    Returns

    .. code-block:: javascript

      {
          "values" : [ "Jaws", "Home Alone" ],
          "stats" : { ... },
          "ok" : 1
      }

.. include:: /includes/student-notes.rst



Example: Using ``distinct()`` C++
---------------------------------

.. code-block:: cpp

  collection coll = conn["sample"]["movie_reviews"];
  cursor c = coll.distinct("name", {})
  for ( auto&& d : c ){
    std::cout << bsoncxx::to_json(d) << std::endl;
  }

.. include:: /includes/student-notes.rst

.. only:: instructor

  .. note::

    A variation between `mongo` shell and **c++** driver is the fact that this
    method return a cursor in the case of the driver while the shell method
    returns a javascript array.

    Although this is the case, the actual command sent to the server always
    returns a cursor.
