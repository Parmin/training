====================
AGGREGATION - STAGES
====================

.. topic:: Learning objectives

    Upon completing this module, students will know:

        - The stages of the aggregation pipeline
        - The basic usages of each stage
        - The syntax associated with these stages

Basic Aggregation Stages
========================

    - match
    - project
    - sort
    - skip
    - limit
    - unwind
    - group
    - out

The Match Stage
---------------

    - The $match operator works just like the matching parameter in a find(),
      update(), or remove() query
    - Documents in the pipeline that match the value will be passed on; those
      that don't will not

Exercise: The Match Stage
~~~~~~~~~~~~~~~~~~~~~~~~~

Use the $match operator to select only the first two documents in the
aggregation pipeline.

.. code-block:: javascript

    matchArr = [ { _id : 1, a : 1 }, { _id : 2, a : 2 }, { _id : 3, a : 3 },
                 { _id : 4, a : 4 }, { _id : 5, a : 5 } ]
    db.aggMatch.insert( matchArr )
    db.aggMatch.find()  // 5 docs
    db.aggMatch.aggregate( [ { $match : { a : { $lte : 2 } } } ] )  
    // 2 docs are output from the aggregation pipeline
    db.aggMatch.find( { a : { $lte : 2 } } )  // same 2 docs

The Project Stage
-----------------

    - The $project operator works like the projection operator in a find()
      query, but is more powerful.
    - You can include fields by passing a 1 for their value in a projection
      document
        - You can exclude the _id by passing a 0 as its value in the 
          projection document
        - As of MongoDB 2.6, you cannot exclude other fields by passing a 0
          as their values
    - You can also rename fields by passing the new name to the $project
      document

Exercise: The $project Operator, Part 1
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Use the $project operator to include only certain fields of a collection.
Use it to exclude _id, as well.

.. code-block:: javascript

    projectArr = matchArr
    db.aggProject.insert( projectArr )
    db.aggProject.update( { }, { $set : { b : 1 } }, { multi : true } )
    db.aggProject.find()  // now there is _id, a, and b
    db.aggProject.aggregate( [ { $project : { a : 1 } } ] )
    // _id and a are there
    db.aggProject.aggregate( [ { $project : { _id : 0, a : 1 } } ] )
    // just a is there
    db.aggProject.insert( { _id : 6, subdoc : { field1 : "asdf", field2: "qwerty" } } )
    db.aggProject.find()
    db.aggProject.aggregate( [ { $project : { a : 1, "subdoc.field1": 1 } } ] )
    // Only field1 appears

Exercise: The $project Operator, Part 2
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Use the $project operator to rename a field

.. code-block:: javascript

    db.aggProject.aggregate( [ { $project : { asdf : "$a", _id : 0, b : 1 } } ] )

Exercise: The $project Operator, Part 3
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Use the $project operator to move a subdocument's field to the top level

.. code-block:: javascript

    db.aggProject.aggregate( [ { $project : { c : "$subdoc.field2", a : 1, b : 1 } } ] )

Exercise: The $project Operator, Part 4
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Use the $project operator to move a top level field into a subdocument

.. code-block:: javascript

    db.aggProject.aggregate( [ { $project : { "otherSubdoc.firstField" : "$a",
                                              b : 1, 
                                              subdoc: 1 } } ] )
    // What was 'a' is now "otherSubdoc.firstfield"
    db.aggProject.aggregate( [ { $project : { "otherSubdoc.firstField" : "$a",
                                              "otherSubdoc.secondField" : "$a",
                                              b : 1, 
                                              subdoc: 1 } } ] )
    // Now we have two copies
    db.aggProject.aggregate( [ { $project : { "otherSubdoc.firstField" : "$a",
                                              "otherSubdoc.bField" : "$b",
                                              subdoc: 1 } } ] )

The Sort Stage
--------------

    - Uses the $sort operator
    - Works just like the .sort() cursor method
        - 1 to sort asciibetically, -1 to sort reverse asciibetically
    - When comparing values of different BSON types, MongoDB uses the following comparison order, from lowest to highest: 
        1. MinKey (internal type)
        2. Null
        3. Numbers (ints, longs, doubles)
        4. Symbol, String
        5. Object
        6. Array
        7. BinData
        8. ObjectId
        9. Boolean
        10. Date, Timestamp
        11. Regular Expression
        12. MaxKey (internal type)
        

The Limit Stage
---------------

    - Used to limit the number of documents returned
    - Just like the .limit() method on the cursor


