===========
Aggregation
===========


Learning Objectives
-------------------

Upon completing this module, students will be able to:

- List and use the new aggregation stages are in MongoDB 3.2
  - $sample
  - $indexStats
  - $lookup
- Use the new or revised operators introduced in MongoDB 3.2

.. include:: /includes/student-notes.rst


Sample Dataset
--------------

`Handout Link <https://raw.githubusercontent.com/thatnerd/work-public/master/mongodb_trainings/companies.zip>`_

Download the handout and unpack.

Next, do the following:

.. code-block:: bash

  $ mongoimport -d training -c companies --drop companies.json

- You now have a dataset of companies on your server.
- We will use these for our examples.


.. include:: /includes/student-notes.rst


New Pipeline Operators
----------------------

- $sample is used to pull in a random set of documents

  - You can specify how many

- $indexStats will tell you how often your indexes are being used

  - Stats are gathered since the server process started

- $lookup is used to pull data from a collection into an aggregation on this collection

  - It uses a key whose values are equal for the two collections

.. include:: /includes/student-notes.rst


Introduction to $sample
-----------------------

- Pulls a random sample of documents from your collection
- Useful for doing statistics

  - As we will see below, MongoDB now has better stastical methods for aggregation

- If it's larger than 5% of the collection, it will perform a collection scan

  - $samples of less than 5% of the collection will not perform a collection scan

.. include:: /includes/student-notes.rst


Example: $sample
----------------

.. code-block:: javascript

   db.companies.aggregate( [ 
        { $sample : { size : 5 } },
        { $project : { _id : 0, number_of_employees: 1 } }
   ] )

.. include:: /includes/student-notes.rst

.. only:: instructor

  .. note::

    - Obvioiusly, they will want their sample sizes to be large enough to be useful; 5 is too small for anything
    - A statistician may be required for determining how much is enough; it depends on the distribution of data
    - On WiredTiger, $sample can be quite slow as of the writing of this content.
  
      - https://jira.mongodb.org/browse/SERVER-23408
      - This is a little slow, currently.
  

Introduction to $indexStats
---------------------------

- Tells you how many times each index has been used

  - Since the server process began

- Must be the first stage of the pipeline
  
  - You can use other stages to aggregate the data

- One document per index

  - A field increments each time the index gets used

.. include:: /includes/student-notes.rst


Example: $indexStats
--------------------

.. code-block:: javascript

  db.companies.dropIndexes()
  db.companies.createIndex( { number_of_employees : 1 } )
  db.companies.aggregate( [ { $indexStats: {} } ] )
  db.companies.find( { number_of_employees : { $gte : 100 } }, { number_of_employees: 1 } ).next()
  db.companies.find( { number_of_employees : { $gte : 100 } }, { number_of_employees: 1 } ).next()
  db.companies.aggregate( [ { $indexStats: {} } ] )

.. only:: instructor

  .. note::

    - Point out the "accesses" doc, with ops, is 0 for the new index initially.
    - Ops incremented to 2 from the two find() queries.
    - _id did not increment because we weren't using the index
    - Neither query changed its "since" field in the "accesses" doc
    - If using replication, the oplog will query on _id when replicating.


Introduction to $lookup
-----------------------

- In SQL terms, performs a left outer join 
- In non-SQL terms, it pulls documents from another collection into the pipeline
 
  - Pulls from an unsharded collection in the same DB

- Matches documents based on a field in each collection that must be equal
- This functionality was previously not available with a single query

.. include:: /includes/student-notes.rst

.. only:: instructor

  .. note::

    - In some sense, this isn't completely *new* functionality
  
      - Previously, you could get this behavior with two separate queries
  
        - One for a collection that contains reference values
        - The other for the referenced collection, using its values


Example: Using $lookup
----------------------

- Let's create a separate collection to $lookup

.. code-block:: javascript

  db.commentOnEmployees.insertMany( [ 
      { employeeCount: 405000, comment: "Biggest company in the set." },
      { employeeCount: 405000, comment: "So you get two comments." },
      { employeeCount: 100000, comment: "This is a suspiciously round number." },
      { employeeCount: 99999, comment: "This is a suspiciously accurate number." },
      { employeeCount: 99998, comment: "This isn't in the data set." }
      ] )
  


.. include:: /includes/student-notes.rst


Example: Using $lookup (Continued)
----------------------------------

.. code-block:: javascript

  db.companies.aggregate( [
    { $match: { number_of_employees: { $in: [ 405000, 388000, 100000, 99999, 99998 ] } } },
    { $project: { _id :0, name: 1, number_of_employees: 1 } },
    { $lookup: {
        from: "commentOnEmployees",
        localField: "number_of_employees",
        foreignField: "employeeCount",
        as: "example_comments"
    } },
    { $sort : { number_of_employees: -1 } } ] )

.. include:: /includes/student-notes.rst

.. only:: instructor

  .. note::
   
    - Note that the comment documents get pushed in their entirety.
    - It includes all companies that made it to the pipeline

      - Even if there is no corresponding comment (as for IBM)

    - Does not include documents in commentOnEmployees that don't match.


$lookup Considerations
----------------------

- You've got a local field and a foreign field (in the foreign collection)

  - These must be equal

- The foreign collection cannot be sharded

  - But the collection you're aggregating on can be

.. include:: /includes/student-notes.rst


New Aggregation Functionality
-----------------------------

- 3.2 introduced a lot of new operators

  - Changed the functionality of a few operators

- Accumulators for $group
- Arithmetic operators
- Array operators
- General enhancements

.. include:: /includes/student-notes.rst


New Accumulators
----------------

- Accumulators do math on a set of numbers

  - Used with $group

- $stdDevSamp - Sample Standard Deviation
- $stdDevPop - Population Standard Deviation

.. code-block:: javascript

  db.companies.aggregate( [
  { $match : { number_of_employees: { $lt: 1000, $gte: 100 } } },
  { $group : {
      _id : null,
      mean_employees: { $avg : "$number_of_employees" },
      std_num_employees : { $stdDevPop: "$number_of_employees" } } }
  ] )

.. include:: /includes/student-notes.rst

.. only:: instructor

  .. note::

    - The standard deviation of a population means you're looking at every member
    - The standard deviation of a sample means just a randomly selected subset of a larger population
    - It is not necessary to use the $sample stage
    - Don't go into the stats any deeper; this isn't a statistics class

      - We used this example just to show the syntax


New Aggregation Arithmetic
--------------------------

- $sqrt: Calculate a square root
- $abs: Calculate the absolute value
- $log: Calculate the logarithm in a specified base
- $log10: Log base 10
- $ln: Natural logarithm

.. include:: /includes/student-notes.rst

.. only:: instructor

  .. note::

    - All of these are well documented if they want to use them
    - But there are too many to practice, so just go over them quick


New Aggregation Arithmetic (Continued)
--------------------------------------

- $pow: Raise a number to an exponent
- $exp: Raise e to a power
- $trunc: Truncate a number to its integer
- $ceil: Return the smallest integer greater than or equal to a specified number
- $floor: Return the largest integer less than or equal to the specified number

.. include:: /includes/student-notes.rst


Example: $trunc
---------------

.. code-block:: javascript

  db.companies.aggregate( [
    { $match : { number_of_employees: { $gte: 100, $lt: 1000 } } },
    { $group : { _id : null, avg_num_employees: { $avg: "$number_of_employees" } } },
    { $project : { _id: 0, avg_num_employees: { $trunc : "$avg_num_employees" } } }
     ] )

.. include:: /includes/student-notes.rst

.. only:: instructor

  .. note::

    - We just selected one arithmetic operator to show
    - They can go to the manual for syntax


New Aggregation Array Operators
-------------------------------

- $slice: returns a portion of an array
- $arrayElemAt: Returns an element at the index
- $concatArrays: Concatenates two or more arrays
- $isArray: Determines if the operand is an array or not
- $filter: Selects a subset of the array, based on the filter

.. include:: /includes/student-notes.rst


Example: $filter
----------------

.. code-block:: javascript

  db.companies.aggregate( [
    { $match : { "funding_rounds.round_code": "e" } },
    { $project : { _id: 0, name: 1, series_e_funding: { $filter: { input: "$funding_rounds", as: "series_e_funding", cond: { $eq : [ "$$series_e_funding.round_code", "e" ] } } } } },
    { $project : { name: 1, "series_e_funding.raised_amount": 1, "series_e_funding.raised_currency_code": 1, "series_e_funding.year": 1, } },
     ] )

.. include:: /includes/student-notes.rst

.. only:: instructor

  .. note::

    - Notice that the "cond" field of the $filter document requires an expression.
    - The use of "$$" is because there's a variable, "series_e_funding", which we're creating in this stage of aggregation.

      - It doesn't yet exist as a field, because the $project round isn't done, yet.


Changes to $unwind Behavior
---------------------------

- $unwind can now be performed on a non-array value, 

  - Returned an error in 3.0

- $unwind is the ability to output empty arrays after an $unwind operator. 
- Output the index or position of the element from an $unwind operation

.. include:: /includes/student-notes.rst


Using Accumulators with $project
--------------------------------



