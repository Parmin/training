====================
AGGREGATION - PART 1
====================

.. topic:: Learning objectives

    Upon completing this module, students will know:

        - The stages of the aggregation pipeline
        - The basic usages of stages similar to cursor methods
        - The syntax associated with these stages

Basic Aggregation Stages
========================

    - match (like the first argument of a find() query)
    - project (like the second argument of a find() query, but more powerful)
    - sort (like the cursor method, but a little simpler)
    - skip (like the cursor method, but a little simpler)
    - limit (like the cursor method, but a little simpler)
    - unwind (used for working with arrays)
    - group (used for combining data in lots of documents)
    - out (creates a new collection from the output of an aggregation
      pipeline)

The Match Stage
---------------

    - The $match operator works just like the matching parameter in a find(),
      update(), or remove() query
    - Documents in the pipeline that match the value will be passed on; those
      that don't will not

Exercise: The Match Stage
~~~~~~~~~~~~~~~~~~~~~~~~~

Use the $match operator to select only the first two documents in the
aggregation pipeline.

.. code-block:: javascript

    matchArr = [ { _id : 1, a : 1 }, { _id : 2, a : 2 }, { _id : 3, a : 3 },
                 { _id : 4, a : 4 }, { _id : 5, a : 5 } ]
    db.aggMatch.insert( matchArr )
    db.aggMatch.find()  // 5 docs
    db.aggMatch.aggregate( [ { $match : { a : { $lte : 2 } } } ] )
    // 2 docs are output from the aggregation pipeline
    db.aggMatch.find( { a : { $lte : 2 } } )  // same 2 docs


Exercise: Using two Stages in the Aggregation pipeline
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Use the match operator to find documents where a is less than 5, and then use
it again to find documents where a is greater than 1.

.. code-block:: javascript

    db.aggMatch.aggregate( [ { $match : { a : { $lt : 5 } } } ] )
    // halfway there.
    db.aggMatch.aggregate( [ { $match : { a : { $lt : 5 } } },
                             { $match : { a : { $gt : 1 } } } ] )
    // Yes, this could have been accomplished in just one stage by making a
    // better matching query, but it gives you the idea of how stages can be
    // chained.

The Project Stage
-----------------

- The $project operator works like the projection operator in a find()
  query, but is more powerful.

- You can include fields by passing a 1 for their value in a projection
  document

  - You can exclude the _id by passing a 0 as its value in the
    projection document

  - As of MongoDB 2.6, you cannot exclude other fields by passing a 0
    as their values

- You can rename fields by passing the new name to the $project
  document

- If you want to add a new field with a numerical value, such as a number
  or an ObjectId, pass a document with key $literal

Exercise: The $project Operator, Part 1
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Use the $project operator to include only certain fields of a collection.
Use it to exclude _id, as well.

.. code-block:: javascript

    projectArr = matchArr
    db.aggProject.insert( projectArr )
    db.aggProject.update( { }, { $set : { b : 1 } }, { multi : true } )
    db.aggProject.find()  // now there is _id, a, and b
    db.aggProject.aggregate( [ { $project : { a : 1 } } ] )
    // _id and a are there
    db.aggProject.aggregate( [ { $project : { _id : 0, a : 1 } } ] )
    // just a is there
    db.aggProject.insert( { _id : 6, subdoc : { field1 : "asdf", field2: "qwerty" } } )
    db.aggProject.find()
    db.aggProject.aggregate( [ { $project : { a : 1, "subdoc.field1": 1 } } ] )
    // Only field1 appears

Now, take the existing documents but add the field, "newId" with an ObjectId
as the value

.. code-block:: javascript

    db.aggProject.aggregate( [ { $project : {
        _id : 1, a : 1, newId : { $literal : ObjectId() } } } ] )

Exercise: The $project Operator, Part 2
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Use the $project operator to rename a field

.. code-block:: javascript

    db.aggProject.aggregate( [ { $project : { asdf : "$a", _id : 0, b : 1 } } ] )

Exercise: The $project Operator, Part 3
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Use the $project operator to move a subdocument's field to the top level

.. code-block:: javascript

    db.aggProject.aggregate( [ { $project : { c : "$subdoc.field2", a : 1, b : 1 } } ] )

Exercise: The $project Operator, Part 4
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Use the $project operator to move a top level field into a subdocument

.. code-block:: javascript

    db.aggProject.aggregate( [ { $project : { "otherSubdoc.firstField" : "$a",
                                              b : 1,
                                              subdoc: 1 } } ] )
    // What was 'a' is now "otherSubdoc.firstfield"
    db.aggProject.aggregate( [ { $project : { "otherSubdoc.firstField" : "$a",
                                              "otherSubdoc.secondField" : "$a",
                                              b : 1,
                                              subdoc: 1 } } ] )
    // Now we have two copies
    db.aggProject.aggregate( [ { $project : { "otherSubdoc.firstField" : "$a",
                                              "otherSubdoc.bField" : "$b",
                                              subdoc: 1 } } ] )

The Sort Stage
--------------

- Uses the $sort operator
- Works just like the .sort() cursor method

  - 1 to sort asciibetically, -1 to sort reverse asciibetically

  - You cannot use $natural, as the aggregation set may not correspond
    well to the original documents

- When comparing values of different BSON types, MongoDB uses the
  following comparison order, from lowest to highest:

    1. MinKey (internal type)

    2. Null

    3. Numbers (ints, longs, doubles)

    4. Symbol, String

    5. Object

    6. Array

    7. BinData

    8. ObjectId

    9. Boolean

    10. Date, Timestamp

    11. Regular Expression

    12. MaxKey (internal type)

Exercise: The $sort Operator
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Please sort a set of documents in increasing value of the 'a' field, then
decreasing, then b increasing and a decreasing

.. code-block:: javascript

    db.aggSort.insert( [ { _id : 1, a : 1, b : 5 },
                         { _id : 2, a : null, b : 5 },
                         { _id : 3, a : -5, b : 3 },
                         { _id : 4, a : "asdf", b : 12 } ] )
    db.aggSort.find()
    db.aggSort.aggregate( [ { $sort : { a : 1 } } ] )
    // Sorted in increasing a, canonically
    db.aggSort.aggregate( [ { $sort : { a : -1 } } ] )
    // Sorted in decreasing a, canonically
    db.aggSort.aggregate( [ { $sort : { b : 1, a : -1 } } ] )
    // Sorted in increasing a, decreasing b

The Skip Stage
--------------

    - Uses the $skip operator
    - Value is an integer for the number to skip

Exercise: The $skip Operator
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Skip the first 3 documents of a set.

.. code-block:: javascript

    for (i=1; i<=5; i++) { db.aggSkip.insert( { _id : i, a : i } ) }
    db.aggSkip.aggregate( [ { $skip : 3 } ] )  // skips the first 3.

The Limit Stage
---------------

    - Used to limit the number of documents returned or passed to the next
      aggregation stage
    - Value is an integer.

Exercise: The $limit Operator
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: javascript

    for (i=1; i<=5; i++) { db.agglimit.insert( { _id : i, a : i } ) }

Limit the number of documents in an aggregation set to 3.

.. code-block:: javascript

    db.aggSkip.aggregate( [ { $limit: 3 } ] )  // limits to the first 3.
