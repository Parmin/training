==================
Index Fundamentals
==================

Learning Objectives
-------------------

Upon completing this module students should understand:

- The impact of indexing on read performance
- The impact of indexing on write performance 
- How to choose effective indexes
- The utility of specific indexes for particular query patterns

.. only:: instructor

   .. note::

     - Ask how many people in the room are familiar with indexes in a relational database. 
     - If the class is already familiar with indexes, just explain that they work the same way in MongoDB. 


Why Indexes? 
------------

TODO: REPLACE WITH FIGURE.

.. figure:: /figures/btree_example.jpg
    :width: 700px
    :align: center

.. only:: instructor

   .. note::

      - Without an index, in order to find all documents matching a query, MongoDB must scan every document in the collection.
      - This is murder for read performance, and often write performance, too. 
      - If all your documents do not fit into memory, the system will page data in and out in order to scan the entire collection. 
      - An index enables MongoDB to locate exactly which documents match the query and where they are located on disk.
      - MongoDB indexes are based on B-trees.


Types of Indexes
----------------

- Single-field indexes
- Compound indexes
- Multikey indexes
- Geospatial indexes
- Text indexes

.. only:: instructor

   .. note::

      - There are also hashed indexes and TTL indexes.
      - We will discuss those elsewhere.
 

Exercise: Using ``explain()``
-----------------------------

- Let's explore what MongoDB does for the following query by using ``explain()``.
- We are projecting only ``user.name`` so that the results are easy to read.

.. code-block:: javascript

   db.tweets.find( { "user.followers_count" : 1000 }, 
                   { "_id" : 0, "user.name": 1 } )

   db.tweets.find( { "user.followers_count" : 1000 } ).explain()


.. only:: instructor

   .. note::

      - Make sure the students are using the sample database.
      - Review the structure of documents in the tweets collection by doing a find().
      - We'll be looking at the user subdocument for documents in this collection.


Results of ``explain()``
------------------------

You will see results similar to the following.

.. code-block:: javascript

   {
       "cursor" : "BasicCursor",
       "isMultiKey" : false,
       "n" : 8,
       "nscannedObjects" : 51428,
       "nscanned" : 51428,
       "nscannedObjectsAllPlans" : 51428,
       "nscannedAllPlans" : 51428,
       "scanAndOrder" : false,
       "indexOnly" : false,
       "nYields" : 401,
       "nChunkSkips" : 0,
       "millis" : 161,
       "server" : "new-host-3.home:27017",
       "filterSet" : false
   }


Understanding ``explain()`` Output
----------------------------------

- ``n`` displays the number of documents that match the query. 
- ``nscannedObjects`` displays the number of documents the retrieval engine considered during the query. 
- ``nscanned`` displays how many documents in an existing index were scanned. 
- An ``nscanned`` value much higher than ``nreturned`` indicates we need a different index.
- Given ``nscannedObjects``, this query will benefit from an index. 


Single-Field Indexes
--------------------

- Based on a single field of the documents in a collection
- The field may be a top-level field
- You may also create an index on fields in embedded documents


Creating an Index
-----------------

- The following creates a single-field index on ``user.followers_count``. 
- ``explain()`` indicated there will be a substantial performance improvement in handling this type of query. 

.. code-block:: javascript

   db.tweets.ensureIndex( { "user.followers_count" : 1 } )
   db.tweets.find( { "user.followers_count" : 1000 } ).explain()

.. only:: instructor

   .. note::

      - nscannedObjects should now be a much smaller number, e.g., 8.
      - Operations teams are accustomed to thinking about indexes. 
      - With MongoDB, developers need to be more involved in the creation and use of indexes.


Indexes and Read/Write Performance
----------------------------------

- Indexes improve read performance for queries that are supported by the index.
- Inserts will be slower when there are indexes that MongoDB must also update.
- The speed of updates may be improved because MongoDB will not need to do a collection scan to find target documents.
- An index is modified any time a document: 

  - Is inserted
  - Is deleted
  - Is updated in such a way that its indexed field changes
  - If an update causes a document to move on disk


Index Limitations
-----------------

- You can have up to 64 indexes per collection.
- You should NEVER be anywhere close to that upper bound. 
- Write performance will degrade to unusable at somewhere between 20-30.


Use Indexes with Care
--------------------- 

- Every query should use an index.  
- Every index should be used by a query.
- Any write operation that touches an indexed field will require each index to be updated.
- Indexes require RAM.
- Be judicious about the choice of key.
- Do not repeat prefixes in your key values.

.. only:: instructor

   .. note::

      - If your system has limited RAM, then using the index will force other data out of memory. 
      - When you need to access those documents, they will need to be paged in again.




    Please talk about sparse
    Please talk about unique
        Enforcement of single B-tree bucket to document pointer clause.

