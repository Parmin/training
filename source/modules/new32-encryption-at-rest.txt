==================
Encryption at Rest
==================


Introduction
------------

- Personally Identifiable Information (PII)
- Complying with regulations governing PII
- E.g., HIPPA, PCI, and FERPA.

.. include:: /includes/student-notes.rst

.. only:: instructor

   .. note::

      - Many organizations store personally identifiable information (PII).
      - They face the challenge of complying with regulations governing PII.
      - These regulations set policies on how PII can be stored or accessed.
      - HIPPA is a federal regulation that, among other things, governs the security of healthcare records.
      - FERPA, also federal regulation, restricts how and with whom student records can be shared.
      - PCI, governs sensitive financial data such as credit card or bank account information
      - There are many different kinds of regulations designed to protect specific kinds of data, similar to these.


Encryption on Disk
------------------

- Regulations require encryption on disk
- Options:

  - Encrypted filesystem
  - Encrypt at application layer
  - Use self-encrypting hardware
  - DBMS that encrypts data

.. include:: /includes/student-notes.rst

.. only:: instructor

   .. note::

      - Compliance with such policies usually requires encryption on disk to prevent unauthorized access.
      - This can be achieved in a number of ways including:

        - The use of an encrypted filesystem
        - Encrypting data at the application layer
        - Using self encrypting hardware.
        - Use a DBMS that encrypts data written to disk (in addition to ordinary authentication and authorization security precautions).


Native Encryption in MongoDB
----------------------------

- In the 3.2 release of MongoDB, we introduced database encryption
- Requires the WiredTiger storage engine
- Available with MongoDB Enterprise


Encryption Mechanics Overview
-----------------------------

- MongoDB encrypts the data files using AES256 keys
- More details on supported encryption algorithms later
- APIs:

  - For integrating with third-party key management solutions
  - For user-managed solutions using a local keyfile

.. include:: instructor

    - In MongoDB, encryption is the process of encoding data files in such a way that only authorized parties can read them.
    - The datafiles are encrypted using an encryption algorithm that takes a random encryption key as input.
    - This generates encrypted data files that can only be read if decrypted with the same key.
    - In order to manage the encryption keys, the engine provides API’s for integrating with 3rd party key management solutions (recommended) and also allows for a user managed solution via a local keyfile.
    

Encryption at Rest
------------------

- In MongoDB encryption is done at the storage layer.
- Data files on disk and the journal are encrypted.
- To decrypt and view data a user must:

  - Have appropriate MongoDB credentials
  - Authenticate against the database

Encryption and Data in Flight
-----------------------------

- Data in memory and over the wire is not encrypted.
- Use SSL or TLS for network connections:

  - To MongoDB from applications
  - For communication between nodes in a distributed MongoDB deployment


Encryption Algorithms
---------------------

- MongoDB supports a variety of encryption schemes.
- We leverage the openSSL library.
- All keys are AES256.
- You may choose between CBC or GCM mode for the encryption algorithm.
- GCM mode offers protection from bit-flipping attacks.
- MongoDB also supports FIPS-mode encryption to be complian with FIPS 140-2. 


Encrypted at Page Level
-----------------------

- All encryption happens at the page level
- As documents are modified, MongoDB only re-encrypts affected pages

Key Management
In reality, encrpyting the data in and of itself is not the hardest part when it comes to achieving compliance. The area that is generally the strictest and hardest to comply with is the safe and secure management of the encryption keys.
Key Wrapping
 In MongoDB the storage engine encrypts each database with a separate key. It achieves this via a key wrapping scheme in which MongoDB wraps all of the individual internal database keys with one external Master Key for each server. In this example we have 3 databases, DB1, DB2, and DB3. each of these databases have a key associated with them that they use to encrpyt/decrypt their data. These internal database keys must then themselves be “wrapped” or encrypted by another externally managed key called the “Master Key”. The Master Key is required in order to startup an encrypted mongoDB node. MongoDB uses special system calls to ensure that none of the keys are ever paged out, swapped, or written to disk in unencrypted form.




It’s also important to know that neither the internal database keys or Master Keys are part of replication. We do not replicate keys or data in an encrypted form. For over the wire encryption in a cluster you should always use SSL or TLS. This means that when initalizing encryption and every time the server is started after that point, the Master Key must be provided. the same key can be provided for each node in a cluster though mongodb recommends you use a different key for each node. 

MongoDB supports two different forms of managing the Master Key. Local keyfile management or integration with a key management appliance via the KMIP protocol.
Local Key Management



Local key management allows you to use a base64 encoded keyfile as your Master Key. This keyfile is managed entirely by the user and it is up to the user to ensure access controls to it are secure. It is possible to achieve compliance using this method, but the burden is placed entirely on the user.

















START of part 2

Demo
openssl rand -base64 32 > keyfile
./mongod --enableEncryption --encryptionKeyFile keyfile
As you can see by the log messages we have successfully started up an encrypted mongodbserver using the specified keyfile.



Third Party Key Management Appliances

Key management appliances are certified, usually FIPS compliant systems that are an accepted and secure way in which to manage keys and prevent your system from being compromised. They are the easiest way to achieve compliance and MongoDB’s recommended method of managing encryption keys.

MongoDB does not support any key management appliances, but rather relies heavily on tried and tested partner solutions for this. These solutions allow you to securely communicate with them via an open protocol named KMIP.

In 3.2 MongoDB has implemented a KMIP client within the database server that can securely communicate with key management appliances in order to create, fetch, and rotate keys. It is important when choosing a key management solution to use with mongo to ensure that it is KMIP compatible.

Demo
I’ve taken the liberty of setting up a third party KMIP server for the purpose of this lesson. Let’s see how this is done.
./mongod --kmipServerName 10.4.120.199 --enableEncryption  --kmipServerCAFile ca.pem --kmipClientCertificateFile client.pem
If no specific key is provided and it is a new system, the server will request a new key be made and use that one going forward. Inspecting the log files we can see the KMIP messages that are being sent to the KMIP server to both create and retrieve the Master Key. and the messages ackowledging we have successfully started an encrypted system.
Key Rotation

Finally, I’d like to talk about key rotation. rotating out the keys is a requirement in many regulated industries that needs to be met usually about once a year. MongoDB provides 2 methods for doing this. 

1. 
The first method is similar to how index builds or upgrades are recommended in MongoDB, which is a rolling fashion. In this we simply delete all of the data on a secondary and restart it which will automatically request a new key and initial sync the data, We wait for the node to fully catch up, then we do the same with the next secondary and wait for it to catch up, then finally we step down the primary, delete the data and restart it as well.

Though this procedure should incur no downtime since you will always have a primary available and it ensures both the internal database and Master Keys are rotated, it can be a lengthy process depending on how long initial syncs will take. 
If using KMIP, an alternative approach is available. [Insert Drawing] One can use the --kmipRotateMasterKey command to re-wrap or re-encrypt the internal database keys. This will not re-encrypt all of the data, only the internal keys but is a compliant way of achieving key rotation. This is because only things encrypted with an externally managed key that could be comprimised must be re-encrypted, which in our case, are just the internal database keys.  




Where are internal encryption keys stored?
Internal WT key value store
Are logs encrypted when encryption is enabled? If not, is being able to read the logs considered a security risk?  It looked like mongod startup identifies how mongod was started and the keyfile used.
No, logs are not encrypted as of 3.2 GA. Being able to read the logs is considered a risk due to sensitive data potentially being written. We require the logs not be encrypted however, as that complicates the debugging process. A log redaction project is in the works in order to output cleartext log information with all sensitive information being redacted out.
If we want to use encryption at rest but we’re not familiar with kmip, what’s a good kmip tutorial?
Each KMIP vendor will have their own server installation instructions. There is an open source implementation called PYKMIP that is definitely a good start. Other then that our release notes and beta documentation do a good job of summarizing how KMIP works with mongo.
How does the KMIP integration know which server is connecting to it? Or rather, how is this identification method generated from server parameters?
Server CA file and clientCertificate files are used. KMIP servers also have varying levels of security to which MAC addresses or IP addresses can be used to confirm users.
How is a KMIP server any more secure than a local key file?  In both cases you have a local file that is the "password" to retrieve data.  (The local key file or the client certificate for the KMIP server.)  Only if the credential on disk is encrypted or else is securely deleted after mongod starts up do you actually have any security.
Yes. You need to protect the client certificate and CA file if you are trying to protect from an insider threat. However, mongo assumes a trusted environment where if you have access to the live filesystem with the correct permissions (thus are an admin) you are trusted. We do not protect against the root user. In this case we protect from a user who steals the physical hard-drive or who has SSH access but not the appropriate filesystem permissions.
Does encryption alter backup procedures in any way?  (It will probably affect de-duping storage systems, and encrypted files will probably be uncompressible, right?)
Encryption is decoupled from replication. Since Cloud/Ops manager is essentially an additional secondary, it should not be affected. However, extra measures must be applied to ensure Cloud/Ops manager does not break compliance in the environment
Is wired Tiger cache “locked” in RAM?
Please clarify?
Does MMS monitoring see whether a node is encrypted?
Not yet. But given that it is a startup parameter viewable in serverStatus, it should be possible to add this fairly easily.
Which regulations specifically allow for rotation of only the external key and not the internal keys.  (Or just as much additional context as you can provide here).
<Answer here>
Does MMS monitoring see whether a node is encrypted?
<Answer here>
How does encryption at rest protect the data while the process is running? It is mentioned that the data is not encrypted in memory, but stated that the data is inaccessible even if the “user” has physical access to the machine but no MongoDB Credentials. What is preventing a dump of the pages in memory for reading outside the context of MongoDB?


