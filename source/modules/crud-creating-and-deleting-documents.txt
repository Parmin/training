============================================
Creating and Deleting Documents (C++ Driver)
============================================

Learning Objectives
-------------------

Upon completing this module students should understand:

- How to insert documents into MongoDB collections.
- ``_id`` fields:
- How to remove documents from a collection
- How to remove a collection from a database
- How to remove a database from a MongoDB deployment

.. include:: /includes/student-notes.rst


Baseline
--------

For the extent of this lab we will be using same baseline code snippet called `crud.cpp`

.. include:: /includes/student-notes.rst

.. only:: instructor

  .. note::

    Please ask your students to go ahead and under the `snippets` folder create a new file called `crud.cpp`
    This file should have one **main** method that we will extend over the set of exercises as they are completed.

    This initial file should look like the following:

    .. code-block:: cpp

      #include <iostream>
      #include <mongocxx/client.hpp>
      #include <mongocxx/cursor.hpp>
      #include <mongocxx/collection.hpp>
      #include <bsoncxx/builder/stream/document.hpp>
      #include <mongocxx/exception/exception.hpp>


      int main(int, char**) {
          try{

          } catch( const mongocxx::exception &e ) {
            std::cout << "caught " << e.what() << std::endl;
          }
          return EXIT_SUCCESS;

      }

Creating New Documents
----------------------

- Create documents using ``insert()``.
- For example:

  .. code-block:: cpp

    // instantiate a connection
    client conn{mongocxx::uri{}};
    //instantiate a collection
    collection coll = conn["sample"]["cpp"];

    //create a document
    auto doc0 = document{} << "name" << "Dwight" << finalize;

    //insert one document
    coll.insert_one(doc0.view());

.. include:: /includes/student-notes.rst

.. only:: instructor

  .. note::

    Make sure you focus students attention on the following aspects:
    - syntactic sugar of the document construction using `<<` operator
    - simple database objects instantiation
    - same api call has new MongoDB 3.2 shell methods

    Also redirect students into the shell so the can also check the creation of these documents

    .. code-block:: bash

      mongo sample
      db.cpp.find()

    And don't forget the compilation instructions:

    .. code-block:: bash

      c++ --std=c++11 crud.cpp -o crud $(pkg-config --cflags --libs libmongocxx)


Implicit ``_id`` Assignment
---------------------------

- We did not specify an ``_id`` in the document we inserted.
- If you do not assign one, MongoDB will create one automatically.
- The value will be of type ObjectId.

.. include:: /includes/student-notes.rst

Example: Assigning _ids
------------------------

Experiment with the following commands.

.. code-block:: cpp

    //assign `_id` field
    auto doc1 = document{} << "_id" << 1 << "name" << "Dwight" << finalize;

    //and fetch back the results
    auto cursor = coll.find({});
    for (auto&& x : cursor) {
      std::cout << "_id: " << x["_id"].get_int32() << std::endl;
    }

.. include:: /includes/student-notes.rst

.. only:: instructor

   .. note::

      - Note that you can assign an _id to be of almost any type.
      - It does not need to be an ObjectId.

      A new method should be created on our `crud.cpp` to express this variation

      .. code-block:: cpp

        void insert_with_id(){
          // instantiate a connection
          client conn{mongocxx::uri{}};
          //instantiate a collection
          collection coll = conn["sample"]["cpp"];
          //create a document
          auto doc1 = document{} << "_id" << 1 << "name" << "Dwight" << finalize;

          //insert the document
          coll.insert_one(doc1.view());
          //
          auto cursor = coll.find({});
          for (auto&& x : cursor) {
            std::cout << "_id: " << x["_id"].get_int32() << std::endl;
          }
        }



Inserts will fail if...
-----------------------

- There is already a document in the collection with that ``_id``.
- You try to assign an array to the ``_id``.
- The argument is not a well-formed document.

.. include:: /includes/student-notes.rst

.. only:: instructor

  .. note::
    Don't forget that if we run multiple times,
    you should ask the students to this,
    we will get a duplicated key error

    .. code-block:: bash

      ./crud
      ./crud


Example: Inserts will fail if...
---------------------------------

.. code-block:: cpp

    //1 - fails to insert document
    auto doc2 = document{} << "_id" << open_array << 0 << 1 << 2<< close_array<< finalize;
    coll.insert_one(doc2.view());

   //2 - succeeds
   auto doc3 = document{} << "_id" << "Eliot" << finalize;
   coll.insert_one(doc3.view());

   //3 - fails because of duplicate id
   auto doc4 = document{} << "_id" << "Eliot" << finalize;
   coll.insert_one(doc4.view());

   //4 - malformed document => compilation error!
   auto doc5 = document{} << "hello" << finalize;
   coll.insert_one(doc5.view());

.. include:: /includes/student-notes.rst

.. only:: instructor

   .. note::

      - 1 fails because array values are not admissible for `_id`
        - one of the very few restrictions for `_id` values
      - 2 succeeds
      - 3 fails because `_id` is a primary key and therefore must be unique
      - 4 fails to compile since malformed BSON objects will be detected at compilation time.



Bulk Inserts
------------

- MongoDB allows applications to perform bulk inserts.
- You may bulk insert using an array of documents.
- The API has two core concepts:

  - Ordered bulk operations
  - Unordered bulk operations

- The main difference is in the way the operations are executed in bulk.

.. only:: instructor

   .. note::

      - In the case of an ordered bulk operation, every operation will be executed in the order they are added to the bulk operation.
      - In the case of an unordered bulk operation however there is no guarantee what order the operations are executed.
      - With an unordered bulk operation, the operations in the list may be reordered to increase performance.

.. include:: /includes/student-notes.rst


Ordered Bulk Insert
-------------------

- For ordered inserts MongoDB will stop processing inserts upon encountering an error.
- Meaning that only inserts occurring before an error will complete.
- The default setting for ``coll.insert_many()`` is an ordered insert.

  - `options::insert{}`

- See the next exercise for an example.

.. include:: /includes/student-notes.rst

.. only:: instructor

  .. note::

    Ask students to extend again the `crud.cpp` file to include a method that
    would insert ordered or unordered depending on a boolean input value

Example: Ordered Bulk Insert
-----------------------------

Experiment with the following bulk insert.

.. code-block:: javascript

    std::vector<bsoncxx::document::view> docs{};

    auto b0 = document{} << "_id" << 0 << "name" << "Soccer" << finalize;
    auto b1 = document{} << "_id" << 1 << "name" << "Rugby" << finalize;
    auto b2 = document{} << "_id" << 0 << "name" << "Tennis" << finalize;
    auto b3 = document{} << "_id" << 2 << "name" << "Football" << finalize;

    docs.push_back(b0.view());
    docs.push_back(b1.view());
    docs.push_back(b2.view());
    docs.push_back(b3.view());

    auto result = coll.insert_many(docs, options::insert{});

.. include:: /includes/student-notes.rst

.. only:: instructor

   .. note::

      - This example has a duplicate key error.
      - Only the first 2 documents will be inserted.
      - Students need to capture the `operation_exception`

      Full block code:

      .. code-block:: cpp

        void insert_many_ordered(){
          // instantiate a connection
          client conn{mongocxx::uri{}};
          //instantiate a collection
          collection coll = conn["sample"]["cpp"];
          //instantiate vector of document views!
          std::vector<bsoncxx::document::view> docs{};

          auto b0 = document{} << "_id" << 0 << "name" << "Soccer" << finalize;
          auto b1 = document{} << "_id" << 1 << "name" << "Rugby" << finalize;
          auto b2 = document{} << "_id" << 0 << "name" << "Tennis" << finalize;
          auto b3 = document{} << "_id" << 2 << "name" << "Football" << finalize;


          docs.push_back(b0.view());
          docs.push_back(b1.view());
          docs.push_back(b2.view());
          docs.push_back(b3.view());


          //insert ordered (default)
          try{
            coll.insert_many(docs, options::insert{});
          } catch ( const operation_exception &ex ) {
            std::cout << "caught op exception -> " << bsoncxx::to_json(ex.raw_server_error()->view()) << std::endl;
          }
        }


Unordered Bulk Insert
---------------------

- Pass ``mongocxx::options::insert`` with `ordered` flag set to false.
- If any given insert fails, MongoDB will still attempt the others.
- The inserts may be executed in a different order from the way in which you specified them.
- The next exercise is very similar to the previous one.
- However, we are using

  .. code-block:: cpp

    auto options = options::insert{};
    options.ordered(false);

- One insert will fail, but all the rest will succeed.

.. include:: /includes/student-notes.rst

.. only:: instructor

  .. note::

    Ask students to change the previous method of `crud.cpp` to insert
    ordered or unordered depending on a boolean input value.

Example: Unordered Bulk Insert
-------------------------------

Experiment with the following bulk insert.

.. code-block:: cpp

    auto b0 = document{} << "_id" << 0 << "name" << "Badminton" << finalize;
    auto b1 = document{} << "_id" << 1 << "name" << "Snooker" << finalize;
    auto b2 = document{} << "_id" << 0 << "name" << "Karts" << finalize;
    auto b3 = document{} << "_id" << 2 << "name" << "Javellin throw" << finalize;

    docs.push_back(b0.view());
    docs.push_back(b1.view());
    docs.push_back(b2.view());
    docs.push_back(b3.view());


    auto options = options::insert{};
    //insert unordered
    options.ordered(false);
    coll.insert_many(docs, options);


.. include:: /includes/student-notes.rst

.. only:: instructor

  .. note::

    Important to refer that an ``operation_exception`` is also going to be
    thrown if there's any sort of error with one of the insert operations.

    Full code :

    .. code-block:: cpp

      void insert_many(bool ordered){
        // instantiate a connection
        client conn{mongocxx::uri{}};
        //instantiate a collection
        collection coll = conn["sample"]["unordered"];
        //instantiate vector of document views!
        std::vector<bsoncxx::document::view> docs{};

        auto b0 = document{} << "_id" << 0 << "name" << "Badminton" << finalize;
        auto b1 = document{} << "_id" << 1 << "name" << "Snooker" << finalize;
        auto b2 = document{} << "_id" << 0 << "name" << "Karts" << finalize;
        auto b3 = document{} << "_id" << 2 << "name" << "Javellin throw" << finalize;

        docs.push_back(b0.view());
        docs.push_back(b1.view());
        docs.push_back(b2.view());
        docs.push_back(b3.view());

        //insert unordered
        auto options = options::insert{};
        options.ordered(ordered);
        try{
          coll.insert_many(docs, options);
        } catch ( const operation_exception &ex ) {
          std::cout << "caught op exception -> " << bsoncxx::to_json(ex.raw_server_error()->view()) << std::endl;
        }
      }


The Shell is a JavaScript Interpreter
-------------------------------------

- Sometimes it is convenient to create test data using a little JavaScript.
- The mongo shell is a fully-functional JavaScript interpreter. You may:

  - Define functions
  - Use loops
  - Assign variables
  - Perform inserts

.. include:: /includes/student-notes.rst


.. include:: /exercises/crud-creating-data-in-the-shell.txt


Deleting Documents
------------------

You may delete documents from a MongoDB deployment in several ways.

- Use ``delete_one`` or ``delete_many`` to delete documents matching a specific set of conditions.
- Drop an entire collection.
- Drop a database.

.. include:: /includes/student-notes.rst


Using ``collection::delete`` methods
------------------------------------

- Remove documents from a collection using ``delete_one()``.
- This command has one required parameter, a query document.
- ``delete_one()`` will remove one document in the collection matching the query document.
- If one passes an empty document it will still just remove one document.
- To remove all documents matching the query document one needs to use ``delete_many()``

.. include:: /includes/student-notes.rst


Example: Removing Documents
----------------------------

Using the previous generated dataset, do a ``find()`` after each ``delete`` command below.

.. code-block:: cpp

   // Remove the first document
   delete_query << "a" << 1;
   coll.delete_one(delete_query.view());

   // $lt is a query operator that enables us to select documents that
   // are less than some value. More on operators soon.
   // Remove three more
   delete_query << "a" << open_document << "$lt" << 5 << close_document ;
   coll.delete_many(delete_query.view());


   // Remove one more
   delete_query << "a" << open_document << "$lt" << 10 << close_document ;
   coll.delete_one(delete_query.view());

   // All documents removed
   coll.delete_many({});

.. include:: /includes/student-notes.rst

.. only:: instructor

  .. note::

    You should take the opportunity to explain the differences between document builder and view.

    For the following example:

    .. code-block:: cpp

      void delete_after_find(){

        // instantiate a connection
        client conn{mongocxx::uri{}};
        //instantiate a collection
        collection coll = conn["sample"]["stuff"];


        auto cursor = coll.find({});
        document delete_query;
        for ( auto&& x : cursor){
          delete_query << "_id" << x["_id"].get_oid();
          auto result = coll.delete_one(delete_query.view());
          std::cout << "Result:  " << result->deleted_count() << std::endl;
        }

      }


      int main(int, char**) {
          try{
            delete_after_find();
          } catch( const exception &e ) {
            std::cout << "caught " << e.what() << std::endl;
          }
          return EXIT_SUCCESS;

      }

    What seems to be the problem ? If we run this code how many deletes will we get?
    The students should mention notice that
    ``delete_query << "_id" << x["_id"].get_oid();`` is appending a new
    _id:oid key value pair to the document builder without actually replacing it:
    ``{_id: 1, _id: 2, _id: 3}``
    Once the buider generates the view, the actual bson structure sent to the
    server, then it will pick only the first ``_id: 1`` pair and therefore try
    to delete always the same document.

    Make sure to notice this with the students and to explain the differences
    between **view** and **document builder**.



Dropping a Collection
---------------------

- You can drop an entire collection with:

  .. code-block:: cpp

    collection coll = conn["sample"]["tobedropped"];
    coll.drop();

- The collection and all documents will be deleted.
- It will also remove any metadata associated with that collection.
- Indexes are one type of metadata removed.
- More on meta data later.

.. include:: /includes/student-notes.rst

.. only:: instructor

   .. note::

      On this section you should ask students to extend the `crud.cpp` file to
      add a drop collection method.


Example: Dropping a Collection
-------------------------------

.. code-block:: javascript

  void drop_collection(){
    // instantiate a connection
    client conn{mongocxx::uri{}};
    //instantiate a collection
    collection coll = conn["sample"]["names"];

    auto b0 = document{} << "_id" << 0 << "name" << "Meghan" << finalize;
    auto b1 = document{} << "_id" << 1 << "name" << "Elizabeth" << finalize;
    auto b2 = document{} << "_id" << 2 << "name" << "Beatriz" << finalize;
    auto b3 = document{} << "_id" << 3 << "name" << "Anna" << finalize;

    coll.drop();
  }

.. include:: /includes/student-notes.rst



Dropping a Database
-------------------

- You can drop an entire database with

  .. code-block:: cpp

    mongocxx::database db = conn["toBeDropped"];
    db.drop();

- This drops the database on which the method is called.
- It also deletes the associated data files from disk, freeing disk space.

.. include:: /includes/student-notes.rst


Example: Dropping a Database
-----------------------------

.. code-block:: cpp

  //insert some data
  //...
  // list all collections
  auto cursor = db.list_collections();
  auto count = std::distance(cursor.begin(), cursor.end());
  std::cout << "Number of collections: " << count << std::endl;

  db.drop();

  cursor = db.list_collections();
  count = std::distance(cursor.begin(), cursor.end());
  std::cout << "Number of collections: " << count << std::endl;

.. include:: /includes/student-notes.rst

.. only:: instructor

  .. note::

    The important note on this section of code is that we can iterate to count
    quickly over a cursor by applying the following pattern
    ``auto count = std::distance(cursor.begin(), cursor.end());``

    A full set drop method could be something like the following:

    .. code-block:: cpp

      void drop_database(){
        // instantiate a connection
        client conn{mongocxx::uri{}};
        //instantiate database object
        database db = conn["tempDB"];
        //instantiate collections
        collection coll1 = db["coll1"];
        collection coll2 = db["coll2"];
        // insert one document on first collection
        auto b1 = document{} << "brand" << "Mercedes Benz" << finalize;
        auto result1 = coll1.insert_one(b1.view());
        std::cout << "Inserted " << bsoncxx::to_json(result1->inserted_id()) << std::endl;
        // insert one document on second collection
        auto b2 = document{} << "drink" << "Gin Tonic" << finalize;
        auto result2 = coll2.insert_one(b2.view());
        std::cout << "Inserted " << bsoncxx::to_json(result2->inserted_id()) << std::endl;

        // list all collections
        auto cursor = db.list_collections();

        auto count = std::distance(cursor.begin(), cursor.end());
        std::cout << "Number of collections: " << count << std::endl;


        db.drop();

        cursor = db.list_collections();
        count = std::distance(cursor.begin(), cursor.end());
        std::cout << "Number of collections: " << count << std::endl;
      }
