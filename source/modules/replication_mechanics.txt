Oplogs

Every Replica Set has an OpLog. This is typically a fixed size. Suppose our OpLog is 1 GB.
When I give a command (db.insert(some_document)), the OpLog stores it, along with a timestamp & sequence number.

Let’s start drawing oplog records in a simplified format: 



Ordinarily, a secondary would try to stay as up-to-date as possible, stepping through the oplog one at a time shortly after each operation gets written by the primary.

But suppose a Secondary was present initially, but it has been unavailable while the OpLog got written. looks at this, and it says “OK, what’s your latest command? ‘Cause I’m ready for #1.” The primary will be like “100”, and the Secondary would be like, “OK, give me all 100.

So then we get something like this:



PRIMARY				Secondary #1		Secondary #2
   -->   -->


Now, if the Secondary #2 has its lowest latency to the other secondary, it’ll get the oplog from secondary #1 instead of from the primary. This might happen if, say, the primary were in Europe, secondary #1 in New York, and secondary #2 in LA

Now, let’s suppose we only have room for 100 documents in our OpLog. Now, the primary will overwrite Operation 1 with Operation 101.


Now, let’s say a secondary goes out.

Now, let’s say another 200 commands come in. 
The Primary and the second Secondary are at command # 301, and then the downed Secondary comes up.

PRIMARY				Secondary #1		Secondary #2
   -->   -->




At this point, this secondary says, “OK, can you give me command 102?” and the Primary and the other Secondary are at 300, and have events 201-300. 
Now, the only way to get the secondary back in sync is with a FULL re-sync: all the data, plus the OpLog.


PRIMARY				Secondary #1		Secondary #2
   -->   → 		





The Secondary does a full re-sync from all of the Primary’s data, and copies the OpLog, and then begins stepping through the OpLog, one by one.


Now, clearly there’s an issue here. What if writes occur partway through the primary’s scan, but then are listed at the end of the OpLog?

Answer: the writes themselves are NOT stored in the OpLog. Insted, “Idempotent” versions of the operations

Idempotent means that repeats of the original statement don’t do anything. It’s about setting a field to a particular value, rather than (say) incrementing or decrementing it.

Some people have issues with Replica Sets that are under such heavy load that by the time a sync occurs, they fall off the oplog. Usually this is evidence that you need a longer OpLog.

By default, the OpLog is 5% of disk space - up to 50GB.

One thing that you can do in order to ensure that your data is replicating, is to set the write concern that are greater than 1. That way, if you run into a problem with the primary

Then you can go on, business as usual. You’ve already written things. 

If you don’t do this, you can get a situation where the primary goes down, and some writes occur that are not communicated to any secondaries.

So suppose that my Primary goes up to 400, but the secondary is only up to 399 when the Primary goes down. The Secondary becomes a Primary at that point, and then goes forward. Its next write is OpLog operation #400. 

Now we have two #400’s. The state of the database is in conflict. What happens? Well, when the old Primary comes back online, the conflict is noted, a process we call “Rollback”. 

If the old primary falls off the OpLog, data about that conflict is lost, as the old primary must take a snapshot and then follow the OpLog of the secondary.
