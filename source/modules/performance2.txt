====================
Performance Tutorial
====================


Learning Objectives
-------------------

Upon completing this module students should understand:

- The tools MongoDB provides for performance analysis
- Tips & tricks to improve performance

.. only:: instructor

  .. note::

    - A node.js program for this exists here: 

      - https://github.com/NathanZamecnik/messagequeue/blob/master/index.js

    - I intend to convert this to something the shell can use at some point.
    - Acts as a message queue, writers write to the system while readers read.
    

Performance Tools Overview
--------------------------

- mongostat
- mongotop
- db.collection.stats()
- db.currentOp()
- the profiler (db.setProfilingLevel())
- db.serverStatus()


Mongostat and Mongotop
----------------------

- Mongostat samples a server every second

  - see current ops, pagefaults, network traffic, etc.
  - does not give a view into historic performance

    - use MMS for that

- Mongotop looks at the time spent on reads/writes in each collection


Exercise: Mongostat
-------------------

Perform the following:

In one window, perform the following query:

.. code-block:: javascript

  db.testcol.drop()
  for (i=1; i<=10000; i++) { 
      arr = [];
      for (j=1; j<=1000; j++) { 
          doc = { _id : (1000 * (i-1) + j), a : i, b : j, c : (1000 * (i-1)+ j)};
          arr.push(doc)
      };
      db.testcol.insert(arr);
      var x = db.testcol.find( { b : 255 } );
      x.next();
      var x = db.testcol.find( { _id : 1000 * (i-1) + 255 } );
      x.next();
      var x = "asdf";
      db.testcol.update( { a : i, b : 255 }, { $set : { d : x.pad(1000) } });
      print(i)
  }

In another window/tab, run mongostat. You will see:

- Inserts
- Queries
- Updates

In a third window, create an index when you see things slowing down:

.. code-block:: javascript

  db.testcol.ensureIndex( { a : 1, b : 1 } )

Look at mongostat. Notice that things are going significantly faster. Then, let's drop that and build yet another index.

  db.testcol.dropIndexes()
  db.testcol.ensureIndex( { b : 1, a : 1 } )


Exercise: Mongotop
------------------

- Perform the following:

.. code-block:: javascript

  db.testcol.drop()
  for (i=1; i<=10000; i++) { 
      arr = [];
      for (j=1; j<=1000; j++) { 
          doc = { _id : (1000 * (i-1) + j), a : i, b : j, c : (1000 * (i-1)+ j)};
          arr.push(doc)
      };
      db.testcol.insert(arr);
      var x = db.testcol.find( { b : 255 } );
      x.next();
      var x = db.testcol.find( { _id : 1000 * (i-1) + 255 } );
      x.next();
      var x = "asdf";
      db.testcol.update( { a : i, b : 255 }, { $set : { d : x.pad(1000) } });
      print(i)
  }

- In another window, run mongotop.
- Note that you can see the activity on the server for reads/writes/total.

db.currentOp()
--------------

- currentOp is a tool that asks what the db is doing at the moment.
- currentOp is useful for finding long-running processes.
- Fields of interest:

  - microsecs_running
  - op
  - query
  - lock
  - waitingForLock


Exercise: db.currentOp()
------------------------

- Perform the following in the shell: 

.. code-block:: javascript

  db.testcol.drop()
  for (i=1; i<=10000; i++) { 
      arr = [];
      for (j=1; j<=1000; j++) { 
          doc = { _id : (1000 * (i-1) + j), a : i, b : j, c : (1000 * (i-1)+ j)};
          arr.push(doc)
      };
      db.testcol.insert(arr);
      var x = db.testcol.find( { b : 255 } );
      x.next();
      var x = db.testcol.find( { _id : 1000 * (i-1) + 255 } );
      x.next();
      var x = "asdf";
      db.testcol.update( { a : i, b : 255 }, { $set : { d : x.pad(1000) } });
      print(i)
  }

- Connect with a separate shell, and repeatedly run db.currentOp()
- Notice that the running time gets longer & longer, on average.



db.collection.stats()
---------------------

- Used to view the current stats for a collection.
- Everything is in bytes; use the multiplier parameter to view in KB, MB, etc
- You can also use db.stats() to do this at scope of the entire database


Exercise: Using Collection Stats
--------------------------------

Look at the output of the following:

.. code-block:: javascript

  db.testcol.drop()  
  db.testcol.insert( { a : 1 } )
  db.testcol.stats()
  var x = "asdf"
  db.testcol2.insert( { a : x.pad(10000000) } )
  db.testcol2.stats()
  db.stats()


The Profiler
------------

- Off by default; to reset, db.setProfilerLevel(0)
- At setting 1, it captures "slow" queries

    - user may define what "slow" is
    - default is 100ms: db.setProfilerLevel(1)
    - e.g., to capture 20 ms: db.setProfilerLevel(1, 20)


The Profiler (continued)
------------------------

- If the profiler level is 2, it captures all queries.

  - This will severely impact performance.
  - Turs all reads into writes.

- Always turn the profiler off when done (set level to 0)
- When on, the profiler writes to db.system.profile


Exercise: Exploring the Profiler
--------------------------------

Perform the following, then look in your db.system.profile.

.. code-block:: javascript

  db.setProfilingLevel(0)
  db.testcol.drop()
  db.system.profile.drop()
  db.setProfilingLevel(2)
  db.testcol.insert( { a : 1 } )
  db.testcol.find()
  var x = "asdf"
  db.testcol.insert( { a : x.pad(10000000) } )  // ~10 MB
  db.setProfilingLevel(0)
  db.system.profile.find().pretty()


.. only:: instructor

  .. note::

    - Mention to the students what the fields mean.
    - Things to keep in mind:

      - op can be command, query, or update
      - ns is sometimes the db.collection namespace
      
        - but sometimes db.$cmd for commands

      - key updates refers to index keys
      - ts (timestamp) is useful for some queries if problems cluster.


Server Status
-------------

- Shown by typing db.serverStatus().
- Takes a snapshot.
- By taking diffs, you can see system trends.
- Most of the data that MMS gets is from here.
- Most useful when taking diffs.


Exercise: Using Server Status
-----------------------------

- Open up two windows. In the first, type: 

.. code-block:: javascript

  db.testcol.drop()
  var x = "asdf"
  for (i=0; i<=10000000; i++) { db.testcol.insert( { a : x.pad(100000) } ) }

- In the second window, type periodically:

.. code-block:: javascript

  var x = db.serverStatus(); x.metrics.document

- You will see how fast documents are getting inserted.
- It will be slow b/c the documents are big.


Performance Improvement Techniques
----------------------------------

- Appropriate write concerns
- Bulk operations
- Good schema design
- Good Shard Key choice
- Good indexes


Performance Tips: Write Concern
-------------------------------

- Increasing the write concern increases data safety
- But it also can hurt performance
- Especially when there are network issues


Performance Tips: Bulk Operations
---------------------------------

- These are more useful the higher the write concern
- Allows the server to bulk write & bulk acknowledge
- Can be done with inserts & updates
- Unordered Bulk Ops can be faster, and will continue on error.


Exercise: Bulk Inserts
----------------------

- First, set up a replica set with seven members.

  - This is easiest with mtools, where you can just type:

    - $ mlaunch init --replicaset --nodes 7

- Perform the following, with writeConcern : 1 and no bulk inserts:

.. code-block:: javascript

  db.testcol.drop()
  for (i=1; i<=10000; i++) { 
      for (j=1; j<=1000; j++) { 
          db.testcol.insert( { _id : (1000 * (i-1) + j), a : i, b : j, c : (1000 * (i-1)+ j) }, { writeConcern : { w : 1 } } );
      };
      print(i);
  }

- Run mongostat and see how fast that happens. 
- Increase the write concern to 7 (safer but slower):

.. code-block:: javascript

  db.testcol.drop()
  for (i=1; i<=10000; i++) { 
      for (j=1; j<=1000; j++) { 
          db.testcol.insert({ _id : (1000 * (i-1) + j), a : i, b : j, c : (1000 * (i-1)+ j)}, { writeConcern : { w : 7 } } );
      };
      print(i);
  }

- Again, run mongostat.
- Finally, let's use bulk inserts to our advantage:
- Note that writeConcern is still { w : 7 } 

.. code-block:: javascript

  db.testcol.drop()
  for (i=1; i<=10000; i++) { 
      arr = []
      for (j=1; j<=1000; j++) { 
          arr.push( { _id : (1000 * (i-1) + j), a : i, b : j, c : (1000 * (i-1)+ j) } );
      };
      db.testcol.insert( arr, { writeConcern : { w : 7 } } );
      print(i);
  }


Schema Design
-------------

- The structure of documents affects performance
- For each call for data from the application:

  - You can have lots of queries, or as few as one.

- For each write operation from the application:

  - You can have lots of updates, or as few as one.

- To see more, see our data modeling section.


Shard Key Choice
----------------

- Your shard key should be based on your most common use case(s).
- It can mean the difference between:
  
  - one of your servers working 
  - all of them working


Indexes and Performance
-----------------------

- Queries (including updates) that don't use an index will cripple performance.
- In compound indexes, order matters:

  - Sort on a field that comes before any range used in the index.
  - You can't skip fields; they must be used in order.
  - For examples, see the 'indexing' section.
