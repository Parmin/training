=====================================
New Cluster Operations in MongoDB 3.2
=====================================


Learning Objectives
-------------------

Upon completing this module, students will be able to:

- Distinguish stale from dirty reads
- Use read concern in MongoDB 3.2
- Describe how read concern prevents dirty reads
- List the features of Replication Protocol 1
- List the features of using config servers as replica sets (CSRS)

.. include:: /includes/student-notes.rst


Background: Stale Reads
-----------------------

- These are reads that may not reflect the most recent writes

  - Can occur when reading from secondaries
  - Networked applications that permit stale reads are called "eventually consistent"

- read preference: "primary" will almost always prevent stale reads

  - See the next slide for a description and counterexample

.. include:: /includes/student-notes.rst

.. only:: instructor

  .. note::

    - Stale reads see a view of the data that was in place at some point in the recent time


Background: Stale Reads and Read Preference
-------------------------------------------

- In rare circumstances, two members may simultaneously believe that they are the primary

  - Only one will get acknowledgement for ``{ w : "majority" }``
  - The other will not yet recognize its demotion to secondary

- Under these circumstances, stale reads can occur if an application reads from the other primary
- Writes to the other primary will eventually get rolled back.

  - Under no circumstances will they get acknowledged

- In cases like these, stale reads are possible

.. include:: /includes/student-notes.rst

.. only:: instructor

  .. note::

    - This slide is for the benefit of engineers who are very knowledgeable about isolation, and who are concerned about isolation levels

      - Telling them that primaries prevent stale reads is not completely accurate
      - This is giving them a sense of why we don't simply say that.

    - The scenario described here might happen if, for example, the other primary freezes for some time, then resumes operation.
    - This is why we can't say that MongoDB is immune to stale reads


Background: Dirty Reads
-----------------------

- Dirty reads occur when you see a view of the data...

  - ... but that view *may* not persist
  - ... even in the history (i.e., oplog)

- Possible if you read non-replicated data from a server 

  - ... because writes could get rolled back

.. include:: /includes/student-notes.rst

.. only:: instructor

  .. note::

    - There's no way to know, during a dirty read, if its view of the data includes a write that will be rolled back


Stale and Dirty Reads
---------------------

.. figure:: /figures/stale-read-and-dirty-read.svg
   :figwidth: 380px
   :align: center

.. include:: /includes/student-notes.rst

.. only:: instructor

  .. note::

    - This shows stale (top figure) and dirty (bottom figure) reads
    - A stale read is a view of the data that was true at some point in the past, but no longer is.
    - A dirty read is a view of data that may not persist


Dirty Reads and Write Concern
-----------------------------

- Write concern alone doesn't prevent dirty reads

  - You can read non-replicated data from the Primary
  - Because that data is vulnerable to rollback, it is a dirty read

- To prevent this, MongoDB has implemented read concern

.. include:: /includes/student-notes.rst

.. only:: instructor

  .. note::

    - Might be a good time to ask how many ways dirty reads can cause inconsistencies
    - Answers: 

      - Primary gets a write, but crashes before the oplog sends data to the secondary
      - Primary and one secondary both get the write, but both crash before it gets to disk on either
      - Primary gets the write, but there is a network partition separating it from the seccondaries; they elect a new primary

        - Write gets rolled back, so it's not in your data set unless manually added

    - Don't let the students conflate read concern with `read Preference <https://docs.mongodb.com/manual/core/read-preference/>`_


Review: Stale vs. Dirty Reads
-----------------------------

- Stale reads reflect old, but valid, views of the data

  - Possibly missing writes after a certain point in time
  - Reading from a secondary makes you more vulnerable

- Dirty reads are reads that reflect data that will not persist

.. include:: /includes/student-notes.rst

.. only:: instructor

  .. note::

    Dirty reads:

    - Can occur due to server failure, network partitions
    - They are, in some sense, invalid views of the data
    - They are only apparent after the fact


Introduction to read Concern
----------------------------

- Created to prevent dirty reads
- Two settings

  - ``local``: read the most recent data on the server
    
    - This is the historical behavior
    - Exposes the application to dirty reads

  - ``majority``: ensures data goes to a majority before it gets read

    - An older version of the data is cached for reads
    - When a majority acknowledges the write, the new version can be read

.. include:: /includes/student-notes.rst

.. only:: instructor

  .. note::

    Questions to ask:

      - Can I avoid dirty reads if I write a document with Write concern ``majority`` and read Preference: ``primary``?

        - Answer: No. Without using read concern level : "majority", you will have dirty reads

      - What can happen if I use a Write concern of ``{ w: 1 }`` and read concern level of ``majority``?

        - Answer: You will not have dirty reads
        
          - ... but you might not be able to read your own writes


Example: Read Concern Level Majority
------------------------------------

.. figure:: /figures/read-concern.svg

.. include:: /includes/student-notes.rst

.. only:: instructor

  .. note:: 

    - This looks quite complicated, but all it's really showing is:
    
      - Two writes, both from App 1, and the associated replication and responses (red and green)
      - Several reads at various times all from App 2 (blue)

    - Note that the applications are using w : "majority" and read concern level: "majority"
    - The application doesn't read a write until after the secondary has confirmed to the primary that it has received the write
    - Key:

      - Red W's are the writes: W1 and W2, as they propagate through
  
        - Dashed red lines are acknowledgments of the writes
  
          - W1S2 is the acknowledgment of write 1 from the S2 server
  
      - Green C's are the read commits from read concern majority. 

        - C1 marks the moment where W1 has been committed
        - C2 marks the moment where W2 has been committed
        - The primary also gets a write acknowledgement when a commit occurs on the primary
        - Note that the commits go from Primary to the secondaries, along with the oplog.

      - Blue R's are the reads from App 2 at various points in time

        - R0 is the initial state
        - R1 is the state after W1 has been committed
        - R2 is the state after W2 has been committed


Quiz
----

What is the difference between a dirty read and a stale read?

.. include:: /includes/student-notes.rst

.. only:: instructor

  .. note:: 

    - Dirty read means you see a write that may not persist
    - Stale read means you don't see a write that has occurred


Read Concern and Read Preference
--------------------------------

- Read Preference determines the server you read from

  - Primary, Secondary, etc.

- Read concern determines the view of the data you see 
- With read concern level: ``majority``... 

  - ... the Primary monitors the state of Secondaries

- The Primary commits the view it knows the majority has

.. include:: /includes/student-notes.rst


Read Concern and Read Preference: Secondary
-------------------------------------------

- Primary has the most current view of the data

  - Secondaries learn which writes are committed from the Primary

- Data on Secondaries can be behind the Primary

  - But *never* ahead of the Primary

.. include:: /includes/student-notes.rst


Using Read Concern 
------------------

- You must:

  - Use WiredTiger on all members
  - Launch mongod with `--enableMajorityReadConcern` on all members

- Use read concern level ``majority`` with write concern ``{ w : "majority" }``

  - Otherwise, an application may not "see" its own writes

.. include:: /includes/student-notes.rst

.. only:: instructor

  .. note:: 

    - If running with read concern level: "majority" but not Write concern ``{ w: "majority" }``, it would be possible to insert a document, get it acknowledged, and then try to read it back, but not see it.

      - They shouldn't do this


Read Concern: Summary
---------------------

- Read concern level: ``majority`` prevents dirty reads
- New in MongoDB 3.2
- Use Write concern ``{ w : "majority" }`` with read concern

  - This way, your application can read its own writes

.. include:: /includes/student-notes.rst


Example: Using Read Concern
---------------------------

- First, launch a replica set.
- A script is in the `shell_scripts` directory of the USB drive.

.. code-block:: bash

  ./launch_replset_for_majority_read_concern.sh

.. include:: /includes/student-notes.rst

.. only:: instructor

  .. note:: 

    - This will allow them to launch a replica set that can use majority read concern.

    .. include:: /includes/launch_replset_for_majority_read_concern.sh


Example: Using Read Concern (Continued)
---------------------------------------

.. literalinclude:: 
   :langauage: shell
   :linenos: 1-11

.. include:: /includes/student-notes.rst

.. only:: instructor

  .. note:: 

    - In this example, students can see that one document will propagate to the secondaries.
    - But the second document, while present on the primary, will not replicate.
    - Encourage them to use their own example (with db.fsyncLock on secondaries).

      - They can use a driver, if they wish.

Quiz
----

What must you do in order to make the database return documents that have been replicated to a majority of the replica set members?

.. include:: /includes/student-notes.rst

.. only:: instructor

  .. note:: 

    Answer:

      - Invoke the mongod with --enableMajorityReadConcern 
      - Use cursor.readConcern("majority") on a read

        - Alternatively, use read concern level ``majority`` with a driver's connection pool


Replication Protocol Version 1
------------------------------

- MongoDB 3.2 introduces Protocol Version 1
- w : "majority" now implies journaling before acknowledgment for all secondaries
- Secondaries write to journal before they acknowledge writes

  - "j" parameter still applies to the primary

.. include:: /includes/student-notes.rst


Replication Protocol Version 1 (Continued)
------------------------------------------

- Adds electionTimeoutMillis as an option

  - How long to wait before calling for an election
  
    - When Secondaries can't see the primary

  - When the Primary loses contact with the majority... 

    - ... this is how long it waits to step down

- Required for read concern level: majority

.. include:: /includes/student-notes.rst

.. only:: instructor

  .. note:: 

    - Old replication protocol is now Replication Protocol 0
    - Previously, secondaries would acknowledge writes before those writes were journaled
    - A short electionTimeoutMillis can result in lots of elections, especially with a flaky network
    - A long electionTimeoutMillis can result in lower availability due to longer failover time


CSRS: Config Servers as Replica Sets
------------------------------------

- Starting with MongoDB 3.2, your config servers can be replica sets

  - Subject to all standard rules of a replica set
  - Using read concern level: majority

- Your config server replica set needs a Primary

  - Without a Primary, the config metadata can't change

    - No chunk splits, no chunk migrations
    - This will last until a new primary is elected

.. include:: /includes/student-notes.rst

.. only:: instructor

  .. note::

    - There are some constraints to a replica set:

      - No arbiters
      - No delayed members
      - requires replication protocol version 1


CSRS: Advantages
----------------

- Provides the same availability guarantees as your data
- Provides the same durability guarantees as your data
- You can tune the size of the replica set
- Not restricted to 3 servers

  - Suitable for large deployments across datacenters

.. include:: /includes/student-notes.rst


Quiz
----

What are the advantages of Replication Protocol 1?

.. include:: /includes/student-notes.rst

.. only:: instructor

  .. note:: 

    - electionTimeoutMillis now tunable
    - Secondaries write to the journal before acknowledging
    - Enables read concern majority

      - This enables config servers as replica sets


Quiz
----

What are the advantages of Config Servers as Replica sets?

.. include:: /includes/student-notes.rst

.. only:: instructor

  .. note:: 

    - You can get the same availability and durability guarantees as you have for your data
    - You can tune the size of the replica set

      - So you're not limited to 3 servers
