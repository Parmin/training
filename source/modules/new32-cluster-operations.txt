=====================================
New Cluster Operations in MongoDB 3.2
=====================================


Learning Objectives
-------------------

Upon completing this module, students will be able to:

- Distinguish stale from dirty reads
- Use read concern in MongoDB 3.2
- Describe how read concern prevents dirty reads
- List the features of Replication Protocol 1
- List the benefits of using config servers as replica sets (CSRS)

.. include:: /includes/student-notes.rst


Background: Stale Reads
-----------------------

- Reads that do not reflect the most recent writes are stale
- These can occur when reading from secondaries
- Systems with stale reads are "eventually consistent"
- Reading from the primary minimizes odds of stale reads

  - They can still occur in rare cases

.. include:: /includes/student-notes.rst

.. only:: instructor

  .. note::

    - Stale reads see a view of the data that was in place at some point recently


Stale Reads on a Primary
------------------------

- In unusual circumstances, two members may simultaneously believe that they are the primary

  - One can acknowledge ``{ w : "majority" }`` writes

    - This is the true primary

  - The other was a primary

    - But a new one has been elected

- In this state, the other primary will serve stale reads


.. include:: /includes/student-notes.rst

.. only:: instructor

  .. note::

    - The scenario described here might happen if, for example, the other primary freezes for some time, then resumes operation
    - This slide is for the benefit of engineers who are very knowledgeable about isolation, and who are concerned about isolation levels

      - Telling them that primaries prevent stale reads is not completely accurate
      - This is giving them a sense of why we don't simply say that.


Background: Dirty Reads
-----------------------

- Dirty reads are not stale reads
- Dirty reads occur when you see a view of the data

  - ... but that view *may* not persist
  - ... even in the history (i.e., oplog)

- Occur when data is read that has not been committed to a majority of the replica set

  - Because that data *could* get rolled back

.. include:: /includes/student-notes.rst

.. only:: instructor

  .. note::

    - There is no way to know during a dirty read if its view of the data includes a write that will be rolled back
    - Here is a good time to ask when writes can get rolled back
    - Answers:

        - If a network partition isolates the primary, a new one will be elected
        - If the primary crashes, a new one will be elected and the old primary's writes will be rolled back


Dirty Reads and Write Concern
-----------------------------

- Write concern alone can not prevent dirty reads

  - Data on the primary may be vulnerable to rollback

- Read concern was implemented to allow developers the option of preventing dirty reads

.. include:: /includes/student-notes.rst

.. only:: instructor

  .. note::

    - Might be a good time to ask how many ways dirty reads can cause inconsistencies
    - Answers:

      - Primary gets a write, but crashes before the oplog sends data to the secondary
      - Primary and one secondary both get the write, but both crash before it gets to disk on either
      - Primary gets the write, but there is a network partition separating it from the seccondaries; they elect a new primary

        - Write gets rolled back, so it's not in your data set unless manually added

    - Don't let the students conflate read concern with `read preference <https://docs.mongodb.com/manual/core/read-preference/>`_


Introduction to Read Concern
----------------------------

- Two settings

  - ``local``: read the most current data on the server

    - This is the historical behavior
    - Exposes the application to dirty reads

  - ``majority``: data updates only when majority acknowledged

    - A version of the data is retained pre-acknowledgment
    - Writes get committed after a majority has them


    - A version of the data is retained pre-acknowledgment
    - Writes get committed after a majority has them

      - Committed first on the primary
      - When a majority acknowledges the write

.. include:: /includes/student-notes.rst

.. only:: instructor

  .. note::

    Questions to ask:

      - Can I avoid dirty reads if I write a document with write concern "majority" and read preference: "primary"?

        - Answer: No. Without using read concern level : "majority", reads can be dirty

      - What can happen if I use a write concern of ``{ w: 1 }`` and read concern level of "majority"?

        - Answer: You will not have dirty reads ... but you may be unable to read your own writes


Example: Read Concern Level Majority
------------------------------------

.. include:: /images/read-concern.rst

.. include:: /includes/student-notes.rst

.. only:: instructor

  .. note::

    - This looks quite complicated, but all it's really showing is:

      - Two writes, both from App 1, and the associated replication and responses (red and green)
      - Several reads at various times all from App 2 (blue)

    - Note that the applications are using w : "majority" and read concern level: "majority"
    - The application doesn't read a write until after the secondary has confirmed to the primary that it has received the write
    - Key:

      - Red W's are the writes: W1 and W2, as they propagate through

        - Dashed red lines are acknowledgments of the writes

          - W1S2 is the acknowledgment of write 1 from the S2 server

      - Green C's are the read commits from read concern "majority".

        - C1 marks the moment where W1 has been committed
        - C2 marks the moment where W2 has been committed
        - The primary also gets a write acknowledgement when a commit occurs on the primary
        - Note that the commits go from primary to the secondaries, along with the oplog.

      - Blue R's are the reads from App 2 at various points in time

        - R0 is the initial state
        - R1 is the state after W1 has been committed
        - R2 is the state after W2 has been committed


Quiz
----

What is the difference between a dirty read and a stale read?

.. include:: /includes/student-notes.rst

.. only:: instructor

  .. note::

    - Dirty read means you see a write that may not persist
    - Stale read means you don't see a write that has occurred


Read Concern and Read Preference
--------------------------------

- Read preference determines the server you read from

  - Primary, secondary, etc.

- Read concern determines the view of the data you see, and does not update its data the moment writes are received

.. include:: /includes/student-notes.rst


Read Concern and Read Preference: Secondary
-------------------------------------------

- The primary has the most current view of the data

  - Secondaries learn which writes are committed from the primary

- Data on secondaries might be behind the primary

  - But never ahead of the primary


.. include:: /includes/student-notes.rst


Using Read Concern
------------------

- To use read concern, you must:

  - Use WiredTiger on all members
  - Launch all mongod's in the set with

    - ``--enableMajorityReadConcern``

  - Specify the read concern level to the driver

- You should:

  - Use write concern ``{ w : "majority" }``
  - Otherwise, an application may not see its own writes

.. include:: /includes/student-notes.rst

.. only:: instructor

  .. note::

    - If running with read concern level: "majority" but not Write concern ``{ w: "majority" }``, it would be possible to insert a document, get it acknowledged, and then try to read it back, but not see it.

      - They shouldn't do this


Example: Using Read Concern
---------------------------

- First, launch a replica set

  - Use ``--enableMajorityReadConcern``

- A script is in the `shell_scripts` directory of the USB drive.

  .. code-block:: bash

    ./launch_replset_for_majority_read_concern.sh

.. include:: /includes/student-notes.rst

.. only:: instructor

  .. note::

    - This will allow them to launch a replica set that can use majority read concern.

    .. include:: /includes/launch_replset_for_majority_read_concern.sh


Example: Using Read Concern (Continued)
---------------------------------------

.. literalinclude:: /includes/read-concern.sh
   :language: bash
   :lines: 1-11

.. include:: /includes/student-notes.rst

.. only:: instructor

  .. note::

    - In this example, students can see that one document will propagate to the secondaries.
    - But the second document, while present on the primary, will not replicate.
    - Encourage them to use their own example (with db.fsyncLock on secondaries).

      - They can use a driver, if they wish.

Quiz
----

What must you do in order to make the database return documents that have been replicated to a majority of the replica set members?

.. include:: /includes/student-notes.rst

.. only:: instructor

  .. note::

    Answer:

      - Invoke the mongod with ``--enableMajorityReadConcern``
      - Use ``cursor.readConcern("majority")`` on a read

        - Alternatively, use read concern level "majority" with a driver's connection pool


Replication Protocol Version 1
------------------------------

- MongoDB 3.2 introduced a new replication protocol.

  - Replication protocol version 1 is the new protocol.
  - Replication protocol version 0 was used in earlier versions of MongoDB.

- With version 1, secondaries now write to disk before acknowledging writes.
- ``{ w : "majority" }`` now implies ``{ j : true }``
- Set the replication protocol version using the ``protocolVersion`` parameter in your replica set configuration.
- Version 1 is the default in MongoDB >=3.2.

.. include:: /includes/student-notes.rst


Replication Protocol Version 1 (continued)
------------------------------------------

- Also adds ``electionTimeoutMillis`` as an option

  - For secondaries: How long to wait before calling for an election
  - For primaries: How long to wait before stepping down

    - After losing contact with the majority
    - This applies to the primary only

- Required for read concern level ``majority``

.. include:: /includes/student-notes.rst

.. only:: instructor

  .. note::

    - The old replication protocol is now known as replication protocol 0
    - Previously, secondaries would acknowledge writes before those writes were journaled
    - A short electionTimeoutMillis can result in lots of elections, especially with a flaky network
    - A long electionTimeoutMillis can result in lower availability due to longer failover time


CSRS: Config Servers as Replica Sets
------------------------------------

- With MongoDB 3.2, config servers can be replica sets

  - Subject to all standard rules of a replica set
  - Using read concern level "majority"

- Your config server replica set needs a primary

  - Without a primary, the config metadata can't change

    - No chunk splits, no chunk migrations
    - This will last until a new primary is elected

.. include:: /includes/student-notes.rst

.. only:: instructor

  .. note::

    - There are some constraints to a replica set:

      - No arbiters
      - No delayed members
      - Requires replication protocol version 1


CSRS: Advantages
----------------

- Provides the same availability guarantees as your data
- Provides the same durability guarantees as your data
- You can tune the size of the replica set

  - Not restricted to 3 servers
  - Suitable for large deployments across data centers

.. include:: /includes/student-notes.rst


Quiz
----

What are the advantages of replication protocol 1?

.. include:: /includes/student-notes.rst

.. only:: instructor

  .. note::

    - electionTimeoutMillis now tunable
    - Secondaries write to the journal before acknowledging
    - Enables read concern "majority"

      - This enables config servers as replica sets


Quiz
----

What are the advantages of config servers as replica sets (CSRS)?

.. include:: /includes/student-notes.rst

.. only:: instructor

  .. note::

    - You can get the same availability and durability guarantees as you have for your data
    - You can tune the size of the config server set
