===============
Partial Indexes
===============

Learning Objectives
-------------------

Upon completing this module, students should be able to:

- Outline how partial indexes work

  - Including the differences between Sparse and Partial Indexes

- List and describe the use cases for partial indexes
- Create and use partial indexes
- Outline the limitations of partial indexes
- Describe the differences and similarities between partial indexes and sparse indexes


.. include:: /includes/student-notes.rst


What are Partial Indexes?
-------------------------

- Standard indexes have one (or more!) index entries per document
- Partial indexes only index some documents in the collection
- Partial indexes can be compound indexes
- Partial indexes can be multikey indexes

.. include:: /includes/student-notes.rst


Creating Partial Indexes
------------------------

- Partial Indexes must specify a "partialFilterExpression"
- Think of this as a query

  - Matching documents get indexed
  - Non-matching documents don't

.. include:: /includes/student-notes.rst


Example: Creating Partial Indexes
---------------------------------

- Start with a collection using the following schema:

.. code-block:: javascript

  { "_id" : 7, "integer" : 7, "importance" : "very" }

- Create a partial index on the "integer" field
- Create it only where "importance" is "very"

.. include:: /includes/student-notes.rst


Example: Creating Partial Indexes (Continued)
---------------------------------------------

.. code-block:: javascript

  > db.integers.createIndex( { integer : 1 },
                             { partialFilterExpression : { importance : "very" },
                               name : "very_important_integers" } )
  {
      "createdCollectionAutomatically" : false,
      "numIndexesBefore" : 1,
      "numIndexesAfter" : 2,
      "ok" : 1
  }

.. include:: /includes/student-notes.rst

.. only:: instructor

  .. note::

    - We are choosing to name this; the name is optional
    - This is a single-field index, but compound indexes are fine
    - The filter field is totally unrelated to the filter field


Partial Indexes: Visualization
------------------------------

.. figure:: /figures/partial_index_and_collection.svg

.. include:: /includes/student-notes.rst

.. only:: instructor

  .. note::

    - This is a diagram of both the index and a possible collection.
    - The index isn't a btree, but it is ordered by the index key.
    
      - The keys are present only for "very" important documents.


Partial Indexes vs. Sparse Indexes
----------------------------------

- Both Sparse and Partial Indexes only index some documents
- Sparse indexes will index any document for which the field is present
- Partial indexes will index for a wide variety of possible patterns
- Sparse indexes are a special case of partial indexes

.. code-blcok:: javascript

  db.integers.createIndex( { importance : 1 },
                           { partialFilterExpression : { importance : { $exists : true } } } 
                          )  // creates the equivalent of a sparse index

.. include:: /includes/student-notes.rst


Question
--------

When you have a partial index on a field in a collection, which documents will have an index key in that index?

.. include:: /includes/student-notes.rst

.. only:: instructor

  .. note::

    - Correct answer: 
     
      - Only those documents where the field matches a particular query (or filter expression)

    - Wrong answers:

      - All documents

        - This is the case for standard indexes. 

      - Only those documents where the field is present

        - This is the case for sparse indexes, which you can now think of as a subset of partial indexes


Partial Indexes - Advantages
----------------------------

- Can (and should) be much smaller than standard indexes

  - Because not all documents get indexed

- If implemented well, they will:

  - Take up much less memory and disk space
  - Be even faster to traverse

.. include:: /includes/student-notes.rst


Partial Indexes - Use Cases
---------------------------

- A partial index is an optimization for a particular query
- A partial index should only be created

  - When the query only reaches a small subset of the collection
  - When no other query hits the unindexed documents

.. include:: /includes/student-notes.rst

.. only:: instructor

  .. note::

    - "A small subset" usually means at least an order of magnitude less


Question
--------

What is a valid use case for a partial index?

.. include:: /includes/student-notes.rst

.. only:: instructor

  .. note::

    - Correct answer:
      
        - When only a small subset of the keys ever get queried, and never any part of the larger set
        - It allows you to save disk space and keep the index smaller when it's in memory

    - Incorrect answers
    
      - Getting full coverage for all index keys present in a field in the collection

        - Useful only in cases where you only need some of the index keys

      - When you want multiple indexes on the same key

        - MongoDB won't allow you to build these
        - They would increase total overhead in the indexes without improving performance


Identifying Partial Indexes
---------------------------

- You can identify a partial index from the output of getIndexes()
- This also allows you to identify the coverage of the index

.. code-block:: javascript

  > db.integers.getIndexes()
  [
    {
      "v" : 1,
      "key" : {
        "_id" : 1
      },
      "name" : "_id_",
      "ns" : "test.integers"
    },
    {
      "v" : 1,
      "key" : {
        "integer" : 1
      },
      "name" : "very_important_integers",
      "ns" : "test.integers",
      "partialFilterExpression" : {
        "importance" : "very"
      }
    }
  ]

.. include:: /includes/student-notes.rst

.. only:: instructor

  .. note::

    - The presence of of a partialFilterExpression indicates a partial index


Creating Partial Indexes
------------------------

- You can use the following expressions for a partialFilterExpression:

  - Equality, i.e., *field : value* or *field : { $eq : value }*
  - $lt, $lte, $gt, $gte
  - $type
  - $and at the top level only

- No other expressions are currently supported

.. include:: /includes/student-notes.rst

.. only:: instructor

  .. note::

    - If they ask for some other logic, you can perform a hack:

      - Manually input a field in every document

        - Write some code in your driver language to filter on
        - If the document should be in the index, set *field : true*
        - Otherwise, set *field : false*

      - When you update the document, update that field, if necessary


Partial Indexes - Pitfalls
--------------------------

- Not used when a query goes outside of the filter range

  - Even if there really are no documents outside of that range

- Not used when the indexed field isn't touched by the query

  - Even if looking only at documents that would be in the index

- You can .explain() queries to verify that the index is used


.. include:: /includes/student-notes.rst


Partial Indexes - Tips
----------------------

- You can .hint() a partial index to ensure that it gets used

  - Be careful; it's easy to write bugs into code this way

- You can't have both a standard and a partial index for a collection

  - Or two partial indexes on the same fields

- You might be able to use a large enough range on your partialFilterExpression to use a partial index for multiple queries

  - Each query would use only a subset of the index
  - This is another area where you should be careful

.. include:: /includes/student-notes.rst

.. only:: instructor

  .. note::

    - .hint()ing an index can sometimes be useful

      - But it can also be dangerous if you .hint() the wrong index

    - The reason why it isn't used is that the index doesn't know when it's going to miss documents

      - So the server has to be careful

Question
--------

Here are your indexes:

.. code-block:: javascript

  > db.scores.getIndexes()
  [
    {
      "v" : 1,
      "key" : {
        "_id" : 1
      },
      "name" : "_id_",
      "ns" : "test.scores"
    },
    {
      "v" : 1,
      "key" : {
        "score" : 1,
        "student_id" : 1
      },
      "name" : "score_1_student_id_1",
      "ns" : "test.scores",
      "partialFilterExpression" : {
        "score" : {
          "$gte" : 0.65
        },
        "subject_name" : "history"
      }
    }
  ]

Which of the following documents are indexed?

.. code-block:: javascript

  { "_id" : ObjectId("56f584eedd48dc94f645bbbc"), "student_id" : 2, "subject_id" : 5, "score" : 0.8427400308789077, "subject_name" : "history" }
  { "_id" : ObjectId("56f584eedd48dc94f645bb87"), "student_id" : 3, "subject_id" : 5, "score" : 0.5709192872517002, "subject_name" : "history" }
  { "_id" : ObjectId("56f584eedd48dc94f645bb88"), "student_id" : 4, "subject_id" : 1, "score" : 0.5655646907360857, "subject_name" : "physics" }
  { "_id" : ObjectId("56f584eedd48dc94f645bb89"), "student_id" : 4, "subject_id" : 1, "score" : 0.7524370314265274, "subject_name" : "physics" }
  { "_id" : ObjectId("56f584eedd48dc94f645bbc6"), "student_id" : 3, "subject_id" : 5, "score" : 0.8934865718211463, "subject_name" : "history" }

.. include:: /includes/student-notes.rst

.. only:: instructor

  .. note::

    - The first and last documents are the ones that will be indexed.

