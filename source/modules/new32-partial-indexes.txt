===============
Partial Indexes
===============

Learning Objectives
-------------------

Upon completing this module, students should be able to:

- Outline how partial indexes work

  - Including differences between Sparse, Partial Indexes

- List and describe the use cases for partial indexes
- Create and use partial indexes
- Outline the tradeoffs of partial indexes


.. include:: /includes/student-notes.rst


What are Partial Indexes?
-------------------------

- Ordinary indexes have one (or more!) key per document

  - Even more if multikey

- Partial indexes only index *some* documents
- Partial indexes can be compound indexes
- Partial indexes can be multikey indexes

.. include:: /includes/student-notes.rst

.. only:: instructor

  .. note::

    - Multikey indexes have multiple points because they have one index key per entry in the array
    - Compound indexes have only one index point per document.


Creating Partial Indexes
------------------------

- Partial Indexes must specify a "partialFilterExpression"
- Think of this as a query

  - Matching documents get indexed
  - Non-matching documents don't

- The expression needn't be on indexed fields 

  - though it can be

.. include:: /includes/student-notes.rst

.. only:: instructor

  .. note::


Example: Creating Partial Indexes
---------------------------------

- Consider the following schema:

.. code-block:: javascript

  { "_id" : 7, "integer" : 7, "importance" : "high" }

- Create a partial index on the "integer" field
- Create it only where "importance" is "high"

.. include:: /includes/student-notes.rst


Example: Creating Partial Indexes (Continued)
---------------------------------------------

.. code-block:: javascript

  > db.integers.createIndex(
      { integer : 1 },
      { partialFilterExpression : { importance : "high" },
      name : "high_importance_integers" } )
  {
      "createdCollectionAutomatically" : false,
      "numIndexesBefore" : 1,
      "numIndexesAfter" : 2,
      "ok" : 1
  }

.. include:: /includes/student-notes.rst

.. only:: instructor

  .. note::

    - We are choosing to name this index; the name is optional
    - This is a single-field index, but compound indexes work the same
    - The filter field is totally unrelated to the indexed field


Partial Indexes: Visualization
------------------------------

.. figure:: /figures/partial_index_and_collection.svg
    :align: center
    :figwidth: 500 px

.. include:: /includes/student-notes.rst

.. only:: instructor

  .. note::

    - This is a diagram of both the partial index and its collection.
    - Not all keys are present
    - Technically, an index would be a btree

      - This is a conceptual index with proper ordering
      - Contains pointers to documents in the collection

    - The keys are present only for "high" importance documents.


Partial Indexes vs. Sparse Indexes
----------------------------------

- Both Sparse and Partial Indexes only index some documents
- Sparse indexes include keys only if the field exists
- Partial indexes have keys for documents with fields that match a pattern
- Sparse indexes are functionally a subset of partial indexes

  - Use partial indexes from now on

.. code-block:: javascript

  > db.integers.createIndex(
      { importance : 1 },
      { partialFilterExpression : { importance : { $exists : true } } } 
      )  // creates the equivalent of a sparse index

.. include:: /includes/student-notes.rst

.. only:: instructor

  .. note::

    - Using { $exists: true } is how to create sparse index functionality using a partial index
    - Sparse indexes still work, but we now recommend people use partial indexes going forward


Question
--------

When you have a partial index on a collection, which documents will have an index key pointing to them?

.. include:: /includes/student-notes.rst

.. only:: instructor

  .. note::

    - Correct answer: 
     
      - Only those documents where the field matches the partialFilterExpression

    - Wrong answers:

      - All documents

        - This is the case for standard indexes. 

      - Only those documents where the field exists

        - This is the case for sparse indexes, which you can now think of as a subset of partial indexes


Partial Indexes - Advantages
----------------------------

- Can (and should) be much smaller than standard indexes

  - Because not all documents get indexed

- If implemented well, they:

  - Take up less memory and disk space
  - Are faster to traverse

.. include:: /includes/student-notes.rst


Partial Indexes - Disadvantages
-------------------------------

- Used only for queries that match the partialFilterExpression
- Prevents other indexes from being built on the same key

  - Simple or compound

.. include:: /includes/student-notes.rst

.. only:: instructor

  .. note::

    - No two indexes for a collection can differ only in their options document, so a partial index will prevent a full index from getting built, and vice versa.

      - A partial index will also prevent other partial indexes from being built on the same fields (with the same ordering)


Partial Indexes - Use Cases
---------------------------

- A partial index is an optimization for a particular search pattern

  - Or a set of related queries

- A partial index should only be created:

  - When the query only reaches a small subset of the collection
  - When no non-matching query of the same shape is used by the application

.. include:: /includes/student-notes.rst

.. only:: instructor

  .. note::

    - "A small subset" usually means at least an order of magnitude less than the full collection -- preferably more
    - The same shape means that the DB uses the query in the same way. Filtering and sorting on the same fields in the same order, for example.


Quiz
----

You use the following queries regularly on your production server:

.. code-block:: javascript

  > db.things.find( { last_update : { $gte : ISODate("2016-01-01") } } )
  > db.things.find( { last_update : { $gte : ISODate("2015-01-01") } } )

You have documents as far back as the year 2005.

- Is this a good use case for a partial index?

  - If not, why not?
  - If so, what should you use as your partial index?

.. include:: /includes/student-notes.rst

.. only:: instructor

  .. note::

    - This is a good use case.
    - The partialFilterExpression should be:

    .. code-block:: javascript

      > { last_update : { $gte : ISODate("2015-01-01") } }

    - This will allow the index to work for both queries


Identifying Partial Indexes
---------------------------

.. code-block:: javascript

  > db.integers.getIndexes()
  [
  ...,
    {
      "v" : 1,
      "key" : {
        "integer" : 1
      },
      "name" : "high_importance_integers",
      "ns" : "test.integers",
      "partialFilterExpression" : {
        "importance" : "high"
      }
    },
    ...
  ]

.. include:: /includes/student-notes.rst

.. only:: instructor

  .. note::

    - You can identify a partial index from the output of getIndexes()
    - The presence of of a partialFilterExpression indicates a partial index
    - This also allows you to identify the coverage of the index
    - This index is on the "integer" field
    - But the partialFilterExpression is on the "importance" field

      - Only indexing the documents with "importance": "high"


Creating Partial Indexes
------------------------

- Supported partialFilterExpression operators:

  - Equality, i.e., *field : value* or *field : { $eq : value }*
  - $lt, $lte, $gt, $gte
  - $type
  - $and at the top level only

- No other expressions are currently supported

.. include:: /includes/student-notes.rst

.. only:: instructor

  .. note::

    - All of this is as of MongoDB 3.2
    - If they ask for some other logic, they can perform a hack by setting a separate field as a flag:

      - Manually input a field, with a value used in every document you want indexed
      - When you update the document, update that field, if necessary
      - This is the technique we have in the example, with { "importance": "high" }

        - There is some overhead with this technique


Partial Indexes - Pitfalls
--------------------------

- Not used when:

  - The indexed field not in the query

  - A query goes outside of the filter range

    - Even if no documents are out of range

- You can .explain() queries to check them

.. include:: /includes/student-notes.rst

.. only:: instructor

  .. note::
    
    - It's a good time to remind students that they should .explain() production queries periodically to ensure that they are working as intended


Partial Indexes - Tips
----------------------

- You can .hint() a partial index to ensure that it gets used

  - Be careful; it's possible to miss documents if done wrong

    - When documents don't match the partialFilterExpression

- Can't have "double coverage" with multiple indexes

  - Or two partial indexes on the same fields

.. include:: /includes/student-notes.rst


Partial Indexes - Tips (Continued)
----------------------------------

- Partial Indexes can still be used for multiple queries

  - Each query would use a subset of the partialFilterExpression
  - This is another area where you should be careful

.. include:: /includes/student-notes.rst

.. only:: instructor

  .. note::

    - .hint()ing an index can sometimes be useful

      - But it can also be dangerous if you .hint() the wrong index

    - The reason why it isn't used is that the index doesn't know when it's going to miss documents

      - So the server has to be careful


Example: No Double Index Coverage
---------------------------------

.. code-block:: javascript

  db.foo.drop()
  db.foo.createIndex( { a : 1, b : -1 }, { partialFilterExpression : { a : { $gte : 100000 } } } )  // works fine
  db.foo.createIndex( { a : 1, b : -1  }, { partialFilterExpression : { a : { $lte : 100000 } } } )  // fails

.. include:: /includes/student-notes.rst

.. only:: instructor

  .. note::

    - Ask them why it fails
    - It fails because there's already an { a : 1, b : -1 } index on this collection

      - You can't have two indexes on the same fields with the same ordering

    - Ask them if they could create an { a : 1, b : 1 } index with { a : { $lte : 100000 } } 

      - They can. It works because it's a fundamentally different index
      - They need to be very careful about index ordering if sorting


Example: Hinting Done Wrong
---------------------------

.. code-block:: javascript

  db.foo.drop()
  docs = []; for (i=1; i<=10; i++) { docs.push( { student_id: i, score : Math.random(), subject_name: "english" } ) }
  db.foo.insertMany( docs )
  docs = []; for (i=1; i<=10; i++) { docs.push( { student_id: i, score : Math.random(), subject_name: "mathematics" } ) }
  db.foo.insertMany( docs )
  db.foo.createIndex( { score : 1 }, { partialFilterExpression : { subject_name: "english" } } )
  db.foo.find( { score : { $gte : 0.5 } } )  // works fine, but does a collection scan
  db.foo.find( { score : { $gte : 0.5 } } ).hint( { score: 1 } ) // misses documents

.. include:: /includes/student-notes.rst

.. only:: instructor

  .. note::

    - The first query is a collection scan 
    
      - This would be *murder* on performance
      - But it wouldn't miss documents

    - The .hint() forces it to use the index

      - But also forces it to skip documents
      - They simply aren't present in the index


Quiz
----

Consider the following parital index. Note the partialFilterExpression in particular:

.. code-block:: javascript

  {
    "v" : 1,
    "key" : {
      "score" : 1,
      "student_id" : 1
    },
    "name" : "score_1_student_id_1",
    "ns" : "test.scores",
    "partialFilterExpression" : {
      "score" : {
        "$gte" : 0.65
      },
      "subject_name" : "history"
    }
  }

.. include:: /includes/student-notes.rst


Quiz (Continued)
----------------

Which of the following documents are indexed?

.. code-block:: javascript

  { "_id" : 1, "student_id" : 2, "score" : 0.84, "subject_name" : "history" }
  { "_id" : 2, "student_id" : 3, "score" : 0.57, "subject_name" : "history" }
  { "_id" : 3, "student_id" : 4, "score" : 0.56, "subject_name" : "physics" }
  { "_id" : 4, "student_id" : 4, "score" : 0.75, "subject_name" : "physics" }
  { "_id" : 5, "student_id" : 3, "score" : 0.89, "subject_name" : "history" }

.. include:: /includes/student-notes.rst

.. only:: instructor

  .. note::

    - The first and last documents are the ones that will be indexed.
