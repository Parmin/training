===============
Partial Indexes
===============

Learning Objectives
-------------------

Upon completing this module, students should be able to:

- Create partial indexes using equality, $exists, $lte, $gte, $type, or $and expressions
- Distinguish expressions that may be used to create a partial index from those that may not. E.g., you canâ€™t use $size as a partial index filter
- Precisely describe how sparse indexes offer a subset of the functionality provided by sparse indexes
- Distinguish operations for which MongoDB will use a partial index from those for which it will not.
- Describe the use cases in which partial indexes might be useful, and why
- Create and use partial indexes
- Outline the limitations of partial indexes

.. include:: /includes/student-notes.rst


Why Use Partial Indexes?
------------------------

- Partial indexes only index a subset of documents in a collection.
- Those that meet a specified filter expression.
- Benefits:

  - Lower storage requirements
  - Reduced performance costs for index creation and maintenance


Scenario
--------

- Suppose we want to store Nginx logs in MongoDB for our website.
- We don't care about requests that originate inside our company.
- We only care about external access.
- A partial index allows us to ignore internal requests.


Data Model
----------

Following is an example document from our logs collection.

.. code-block:: javascript

    {
      ipStr: "97.86.248.195",
      ip: 1633089731,
      referrer: "https://www.mongodb.com/what-is-mongodb",
      method: "GET"
      resource: "http://www.mongodb.com/assets/metlife.png",
      httpVersion: "HTTP/1.1",
      status: "200",
      bodyBytesSent: 11195,
      ISODate("2012-07-14T01:00:00+01:00")
      timestamp: ISODate("2016-04-05T01:00:39-04:00"),
      httpUserAgent: 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.110 Safari/537.36'
    }


Our filter
----------
- We will filter log entries based on ip range.
- Internal ip addresses fall into the range:

  ..

     "74.113.166.192" to "74.113.166.255"

 - To create a partial index we must define a filter expression.
 - In this case we can use expression below.
 - Rather than strings for ip addresses, we'll use longs.
 - These are stored in the `ip` field in our data model.

   .. code-block:: javascript

      {ip: { $gte: 1248962240, $lte: 1248962303}}


Creating a partial index
------------------------

- Specify a "partialFilterExpression"
- Documents that match are indexed
- Non-matching documents are not
- To create our partial index on ip addresses:

  .. code-block:: javascript

     db.nginxlog.createIndex(
         {resource: 1, httpReferrer: 1},
         {partialFilterExpression:
             {ip: {$gte: 1248962240,
                   $lte: 1248962303}}
         })

- When creating a partial index, the filter expression need not be on indexed fields (though it can be).

.. include:: /includes/student-notes.rst


Partial Indexes: Visualization
------------------------------

.. figure:: /figures/partial_index_and_collection.svg
    :align: center
    :figwidth: 500 px

.. include:: /includes/student-notes.rst

.. only:: instructor

  .. note::

    - This is a diagram of both the partial index and its collection.
    - The index isn't a btree, but it is ordered by the index key.

      - The keys are present only for "very" important documents.


Partial Indexes vs. Sparse Indexes
----------------------------------

- Both Sparse and Partial Indexes only index some documents
- Sparse indexes include keys only if the field is present
- Partial indexes could have keys for a variety of patterns
- Sparse indexes are a special case of partial indexes


Example: Partial vs. Sparse Indexes
-----------------------------------

- Continuing with our web server logs example, imagine we needed an index on httpReferrer.
- Not all documents have a referrer field.
- The following creates the equivalent of a sparse index on this field using partial index syntax.

.. code-block:: javascript

  db.integers.createIndex(
      {referrer: 1},
      {partialFilterExpression: {referrer: {$exists: true}}});

.. include:: /includes/student-notes.rst


Question
--------

When you have a partial index on a collection, which documents will have an index key pointing to them?

.. include:: /includes/student-notes.rst

.. only:: instructor

  .. note::

    - Correct answer:

      - Only those documents where the field matches the partialFilterExpression

    - Wrong answers:

      - All documents

        - This is the case for standard indexes.

      - Only those documents where the field exists

        - This is the case for sparse indexes, which you can now think of as a subset of partial indexes


Partial Indexes - Advantages
----------------------------

- Can (and should) be much smaller than standard indexes

  - Because not all documents get indexed

- If implemented well, they will:

  - Take up less memory and disk space
  - Be even faster to traverse

.. include:: /includes/student-notes.rst


Partial Indexes - Disadvantages
-------------------------------

- Can't accommodate queries that don't match the partialFilterExpression
- May not always be used in situations where they should be

  - Because the server may not realize that it's only looking for documents in the partial index

- Prevents other indexes from being built

.. include:: /includes/student-notes.rst

.. only:: instructor

  .. note::

    - No two indexes for a collection can differ only in their options document, so a partial index will prevent a full index from getting built, and vice versa.

      - A partial index will also prevent other partial indexes from being built on the same fields (with the same ordering)


Partial Indexes - Use Cases
---------------------------

- A partial index is an optimization for a particular query

  - Or a set of related queries

- A partial index should only be created

  - When the query only reaches a small subset of the collection
  - When no other query of the same shape needs to be indexed

.. include:: /includes/student-notes.rst

.. only:: instructor

  .. note::

    - "A small subset" usually means at least an order of magnitude less than the full collection -- preferably more
    - The same shape means that the DB uses the query in the same way. Filtering and sorting on the same fields in the same order, for example.


Question
--------

What is a valid use case for a partial index?

.. include:: /includes/student-notes.rst

.. only:: instructor

  .. note::

    - Correct answer:

        - When only a small subset of the documents ever get queried by the index
        - And you want to to save system resources relative to having a full index

    - Incorrect answers

      - Getting full coverage for all index keys present in a field in the collection

        - Useful only in cases where you only need some of the index keys

      - When you want multiple indexes on the same key

        - MongoDB won't allow you to build these
        - They would increase total overhead in the indexes without improving performance


Identifying Partial Indexes
---------------------------

.. code-block:: javascript

  > db.integers.getIndexes()
  [
  ...,
    {
      "v" : 1,
      "key" : {
        "integer" : 1
      },
      "name" : "very_important_integers",
      "ns" : "test.integers",
      "partialFilterExpression" : {
        "importance" : "very"
      }
    },
    ...
  ]

.. include:: /includes/student-notes.rst

.. only:: instructor

  .. note::

    - You can identify a partial index from the output of getIndexes()
    - This also allows you to identify the coverage of the index
    - The presence of of a partialFilterExpression indicates a partial index


Creating Partial Indexes
------------------------

- You can use the following expressions for a partialFilterExpression:

  - Equality, i.e., *field : value* or *field : { $eq : value }*
  - $lt, $lte, $gt, $gte
  - $type
  - $and at the top level only

- No other expressions are currently supported

.. include:: /includes/student-notes.rst

.. only:: instructor

  .. note::

    - If they ask for some other logic, you can perform a hack by setting a separate field as a flag:

      - Manually input a field, with a value used in every document you want indexed
      - When you update the document, update that field, if necessary
      - This is the technique we have in the example, with { "important": "very" }


Partial Indexes - Pitfalls
--------------------------

- Not used when a query goes outside of the filter range

  - Even if there really are no documents outside of that range

- Not used when the indexed field isn't touched by the query

  - Even if looking only at documents that would be in the index

- You can .explain() queries to verify that the index is used


.. include:: /includes/student-notes.rst


Partial Indexes - Tips
----------------------

- You can .hint() a partial index to ensure that it gets used

  - Be careful; it's easy to write bugs into code this way

- You can't have both a standard and a partial index for a collection

  - Or two partial indexes on the same fields

- You might be able to use a large enough range on your partialFilterExpression to use a partial index for multiple queries

  - Each query would use only a subset of the index
  - This is another area where you should be careful

.. include:: /includes/student-notes.rst

.. only:: instructor

  .. note::

    - .hint()ing an index can sometimes be useful

      - But it can also be dangerous if you .hint() the wrong index

    - The reason why it isn't used is that the index doesn't know when it's going to miss documents

      - So the server has to be careful

Question
--------

Consider the following parital index. Note the partialFilterExpression in particular:

.. code-block:: javascript

  {
    "v" : 1,
    "key" : {
      "score" : 1,
      "student_id" : 1
    },
    "name" : "score_1_student_id_1",
    "ns" : "test.scores",
    "partialFilterExpression" : {
      "score" : {
        "$gte" : 0.65
      },
      "subject_name" : "history"
    }
  }

.. include:: /includes/student-notes.rst


Question (Continued)
--------------------

Which of the following documents are indexed?

.. code-block:: javascript

  { "_id" : 1, "student_id" : 2, "score" : 0.84, "subject_name" : "history" }
  { "_id" : 2, "student_id" : 3, "score" : 0.57, "subject_name" : "history" }
  { "_id" : 3, "student_id" : 4, "score" : 0.56, "subject_name" : "physics" }
  { "_id" : 4, "student_id" : 4, "score" : 0.75, "subject_name" : "physics" }
  { "_id" : 5, "student_id" : 3, "score" : 0.89, "subject_name" : "history" }

.. include:: /includes/student-notes.rst

.. only:: instructor

  .. note::

    - The first and last documents are the ones that will be indexed.
