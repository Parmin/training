===============================================
Lab: Data Model for an "Internet of Things" App
===============================================

Introduction
------------

Consier an internet-connected pill bottle. It will:

- Weigh its contents.
- Track how many pills it contains, when pills are removed, and how many.
- Send heartbeats to confirm it's connected to wi-fi

There will also be a "notification" server. It will:

- Query periodically to find out:

  - Which users are late in taking a pill
  - Which bottles are left open
  - Which bottles are not logging heartbeats

- Notify the appropriate users, and log the notifications

.. include:: /includes/student-notes.rst


Information Outside of the Scope of this Problem
------------------------------------------------

To keep the scope of the problem contained, you **don't** need to model this
data:

- A ``users`` collection with information on the user (including which bottles
  they own and what they contain)
- A ``bottles`` collection with information on the bottle (including which
  medication it contains, how much each pill weighs, etc.)
- A ``notifications`` collection to record the history of notifications sent to
  a user

You can reference a ``bottle_id`` or ``user_id`` or anything else if you think
it should be associated with any of the data you *are* modeling.

Assume that the notification server knows where to send notifications for each
user once it has a user_id.

.. include:: /includes/student-notes.rst


Pill Bottle Operations
----------------------

For simplicity, we will focus on just queries and writes from the bottles and from the
notification server.

Each pill bottle will perform the following queries:

.. rst-class:: longlist

  - A heartbeat
  
    - Frequency: once every 10 minutes

- An operation to log relevant information when the bottle is opened or closed:

  - Frequency: 1-6 times per bottle per day (assume an average of 2)
  - Enough information for the server to know when a medication dosage has
    been missed, and which user it's from.

.. include:: /includes/student-notes.rst


Notifcation Server Operations
-----------------------------

The notification server will query the data from the pill bottles to determine:

- Whether any given bottle is late in dispensing a dosage
- Whether any given bottle has not sent a heartbeat for over an hour

In either case, the server will need to know:

- Which user the bottle is associated with
- Which medication the bottle contains

.. include:: /includes/student-notes.rst


Deliverables
------------

Break into groups of two or three and work together to create the following
deliverables:

- Assumptions about sizing

  - Number of documents per collection
  - Estimated data size
  - Frequency of requests

- Sample documents for each collection you're creating
- Queries the application will use
- Index creation commands
- Should you shard some collections? Now? Later?

  - Let's assume that you'd like for it to take off, and the market is up to 1
    billion customers, worldwide. It's at 100 million today.

.. include:: /includes/student-notes.rst


Solution
--------

All slides from now on should be shown only after a solution is found by the
groups & presented.

.. include:: /includes/student-notes.rst


Solution - Sizing for Operations
--------------------------------

- Assume 100M customers in the first 3 years (up to 1B later)
- Average of 3 bottles per customer
- Average of 2 times per day for users to take their pills (bottle open &
  bottle closed), so 4 actions get logged

Bottle Operations:

- Record bottle heartbeats:

  - 3 bottles per user * 100M users / 600 sec per heartbeat = 5M heartbeats per second (inserts)

- Record bottles opened/closed:

  - 3 bottles per user * 100M users * 2 dosages per day * 2 actions per dosage
    (open & close) / 86400 seconds per day = 14K actions per second (inserts)

Notifcation Server Operations:

- Query for Missing Heartbeats every hour:

  - 3 bottles per user * 100M users / 3600 sec in 10 minutes = 80K checks per
    second for most recent heartbeat

- Query for Missing Dosages every Hour (check the last 3 dosages)

  - 3 bottles per user * 100M users / 3600 seconds between checks = 80k checks
    per second 

- Query for Leaving a Bottle Open every 10 Minutes

  - 3 bottles per user * 100M users / 600 sec per heartbeat = 500K checks per
    second

.. include:: /includes/student-notes.rst


Solution - Sizing for Data
--------------------------

Data size:

- Heartbeats: 300M bottles * 1000 documents per week * 100 bytes per doc = 
  ``30TB per week``
- Open/close: 300M bottles * 2 dosages per day * 2 actions per dose * 100 bytes
  per doc = ``60 GB per week``, or ``3 TB per year``
- Indexes will take up additional space

.. note::

  Document sizes are approximate, and here to give us 

.. include:: /includes/student-notes.rst


Solution - Collections (1 of 2)
-------------------------------

``bottle_actions``

- Bottle it's associated with
- Medication in the bottle
- User who owns the bottle
- Mass of contents
- Estimated number of pills
- Timestamp of measurement
- Action: ``"opened"``, or ``"closed"``

  - If ``"closed"``, also store the number of pills taken while the bottle was
    open

.. include:: /includes/student-notes.rst


Solution - Collections (2 of 2)
-------------------------------

``bottle_heartbeats``

  - Bottle sending in the heartbeat
  - Medication in the bottle
  - User who owns the bottle
  - timestamp

.. include:: /includes/student-notes.rst


Solution - Considerations
-------------------------

- Finding the most recent "heartbeat" will be the *most* common query
  operation, so we should optimize for that.

  - The heartbeat inserts don't benefit from an index, and are hurt by having
    too many indexes

- Are there any health data regulation that requires us to keep the
  last X heartbeats or actions from a user for a period of time?

  - This solution will assume we keep the heartbeats for 1 week, and actions
    (opened/closed) will be kept for ever.

.. include:: /includes/student-notes.rst


Solution: Document (1 of 2)
---------------------------

``bottle_action`` collection

.. code-block:: javascript

  {
    _id : ObjectId(...),
    bottle_id : ObjectId(...),  // Which bottle it refers to
    user_id : "willcross1024",
    medication : "Cordrazine",
    mass_of_contents : 44.25,
    number_of_pills : 25,
    time : ISODate(...),
    action : "closed",  // other possible value: "opened"
    pills_taken : 2  // pills_taken will be present only for the "closed" action.
  }

.. include:: /includes/student-notes.rst


Solution: Document (2 of 2)
---------------------------

``bottle_heartbeats`` collection

.. code-block:: javascript

  {
    _id : ObjectId(...),
    bottle_id : ObjectId(...),
    user_id : "willcross1024",
    medication : "Cordrazine",
    time : ISODate(...)
  }

.. include:: /includes/student-notes.rst


Solution: Pill Bottle Write (1 of 3)
------------------------------------

pill bottle opened

.. code-block:: javascript

  db.bottle_actions.insertOne(
  {
    bottle_id : ObjectId(...),
    user_id : "williamcross1024",
    medication : "Cordrazine",
    mass_of_contents : 44.25,
    number_of_pills : 25,
    time : ISODate(...),
    action : "opened"
  }

.. include:: /includes/student-notes.rst


Solution: Pill Bottle Write (2 of 3)
------------------------------------

pill bottle closed

.. code-block:: javascript

  db.bottle_actions.insertOne(
  {
    bottle_id : ObjectId(...),
    user_id : "willcross",
    medication : "Cordrazine",
    mass_of_contents : 40.48,
    number_of_pills : 23,
    time : ISODate(),
    action : "closed",
    pills_taken : 2
  } )

.. include:: /includes/student-notes.rst


Solution: Pill Bottle Write (3 of 3)
------------------------------------

send heartbeat every 10 minutes

.. code-block:: javascript

  db.bottle_heartbeats.insertOne(
  {
    bottle_id : ObjectId(...),
    user_id : "williamcross1024",
    medication : "Cordrazine",
    time : ISODate(...)
  }

.. include:: /includes/student-notes.rst


Solution: Query (1 of 3)
------------------------

Looking at the last 3 dosages taken to check for a missing one

.. code-block:: javascript

  db.bottle_actions.find(
    {
      bottle_id : ObjectId(...),
      action : "closed", pills_taken : { $gt : 0 }
    },
    { _id : 0, time : 1, pills_taken : 1, user_id : 1, medication : 1 }
  ).sort( { time : -1 } ).limit(3)

.. include:: /includes/student-notes.rst


Solution: Query (2 of 3)
------------------------

Looking at the last action (to see if it is "opened"), and the timestamp (to
see if it was more than 10 minutes ago) to check for an open bottle

.. code-block:: javascript

  db.bottle_actions.find(
    {
        bottle_id : ObjectId(...)
    },
    { _id : 0, time : 1, action : 1, user_id : 1, medication : 1 }
  ).sort( { time : -1 } ).limit(1)

.. include:: /includes/student-notes.rst


Solution: Query (3 of 3)
------------------------

Check last heartbeat to see if it has been >10 minutes

.. code-block:: javascript

  db.bottle_heartbeats.find(
    { bottle_id : ObjectId(...) },
    { _id : 0, time : 1, user_id : 1, medication : 1 }
  ).sort( { time : -1 } ).limit(1)

.. include:: /includes/student-notes.rst


Solution: Indexes
-----------------

.. code-block:: javascript

  db.bottle_actions.createIndex(
    {
        bottle_id : 1, action : 1, time : 1,
        pills_taken : 1, user_id : 1, medication : 1
    },
    { name : "find_missed_dosages" }
  )  // optimizes Query 1, AND allows for covered queries

  db.bottle_actions.createIndex(
    { bottle_id : 1, time : 1, action : 1, user_id : 1, medication : 1 },
    { name : "find_open_bottles" }
  )  // optimizes Query 2, AND allows for covered queries

  db.bottle_heartbeats.createIndex(
    { bottle_id : 1, time : 1, user_id : 1, medication : 1 },
    { name : "find_last_heartbeat" }
  )  // optimizes Query 3, AND allows for covered queries

  db.bottle_heartbeats.createIndex(
    { time : 1 }, { expireAfterSeconds : 604800 },
    { name : "TTL" }
  ) // TTL Index: Delete the heartbeats after 1 week

.. include:: /includes/student-notes.rst

.. only:: instructor

  .. note::

    Each of these indexes is constructed very deliberately.

    - ``find_missed_dosages``

      - Exact match on ``bottle_id`` and ``action``, so those come first
      - Sort by ``time``, so that comes next
      - Range match on ``pills_taken``, so that comes *after* the sort field
        (``time``)
      - Projection also requires ``user_id`` and ``medication``, so those are
        added to make it a covered query.

    - ``find_open_bottles``

      - Exact match on ``bottle_id``, so that comes first
      - Sort by ``time``, so that comes next
      - Projection also returns ``action``, ``user_id``, and ``medication``, so
        those fields are included to make it a covered query.

    - ``find_last_heartbeat``

      - Exact match on ``bottle_id``, so that comes first
      - Sort by ``time``, so that comes next
      - Add ``user_id`` and  ``medication`` to make it a covered query.

    - ``name : "TTL"``

      - Not used in any queries
      - TTL index: the database deletes the heartbeat documents after 1 week


Sharding
--------

From a data storage point of view:

- Sharding *would* be needed to keep heartbeats over a long period of time, if
  we didn't delete them.
- For the actions, this is just a few terabytes per year; no real need to shard.

From an operation point of view:

- 5M writes per seconds is a *lot* for a simple replica set. Either shard, or
  reduce the number of writes

.. include:: /includes/student-notes.rst


Good shard key for "bottle_heartbeats" collection
-------------------------------------------------

Good options:

A) ``{ user_id : 1, time : 1 }``

B) ``{ bottle_id : 1, time : 1 }``

- We can see that the index named ``find_last_heartbeat`` has a prefix that matches ``B.``, so
  that's our shard key.

.. note::

  - Including the ``time`` field ensures good cardinality, even if we have a
    *lot* of documents for each bottle (or each user).
  - Putting the time field after a non-monotonically increasing field ensures
    that there will never be a "hot" server for the inserts.

    - The ``bottle_id`` field *is* an ObjectId, *but* once a bottle is created,
      its heartbeats all have a fixed ``bottle_id``, so this is fine. 

.. include:: /includes/student-notes.rst

.. only:: instructor

  .. note::

    "Hot" servers happen in cases where a shard key has values that are
    monotonically increasing with time. In these cases, one chunk will include
    the range from ``<some point in the past>`` to ``MaxKey``, and all inserts
    will go to that server.

    Reference: https://docs.mongodb.com/manual/core/sharding-shard-key/#monotonically-changing-shard-keys
